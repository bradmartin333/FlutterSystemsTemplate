// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to json_library and dart
class NativeJSON {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeJSON(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeJSON.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Char> hello_json() {
    return _hello_json();
  }

  late final _hello_jsonPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'hello_json');
  late final _hello_json =
      _hello_jsonPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int foo(
    int i,
    int port,
  ) {
    return _foo(
      i,
      port,
    );
  }

  late final _fooPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int64)>>(
          'foo');
  late final _foo = _fooPtr.asFunction<int Function(int, int)>();

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt,
              ffi.UintPtr)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, int, int)>();

  void _wassert(
    ffi.Pointer<ffi.WChar> _Message,
    ffi.Pointer<ffi.WChar> _File,
    int _Line,
  ) {
    return __wassert(
      _Message,
      _File,
      _Line,
    );
  }

  late final __wassertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt)>>('_wassert');
  late final __wassert = __wassertPtr.asFunction<
      void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int imaxabs(
    int _Number,
  ) {
    return _imaxabs(
      _Number,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int _Numerator,
    int _Denominator,
  ) {
    return _imaxdiv(
      _Numerator,
      _Denominator,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _EndPtr,
    int _Radix,
  ) {
    return _strtoimax(
      _String,
      _EndPtr,
      _Radix,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int _strtoimax_l(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _EndPtr,
    int _Radix,
    _locale_t _Locale,
  ) {
    return __strtoimax_l(
      _String,
      _EndPtr,
      _Radix,
      _Locale,
    );
  }

  late final __strtoimax_lPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              _locale_t)>>('_strtoimax_l');
  late final __strtoimax_l = __strtoimax_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int, _locale_t)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _EndPtr,
    int _Radix,
  ) {
    return _strtoumax(
      _String,
      _EndPtr,
      _Radix,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int _strtoumax_l(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _EndPtr,
    int _Radix,
    _locale_t _Locale,
  ) {
    return __strtoumax_l(
      _String,
      _EndPtr,
      _Radix,
      _Locale,
    );
  }

  late final __strtoumax_lPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              _locale_t)>>('_strtoumax_l');
  late final __strtoumax_l = __strtoumax_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int, _locale_t)>();

  int wcstoimax(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _EndPtr,
    int _Radix,
  ) {
    return _wcstoimax(
      _String,
      _EndPtr,
      _Radix,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int _wcstoimax_l(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _EndPtr,
    int _Radix,
    _locale_t _Locale,
  ) {
    return __wcstoimax_l(
      _String,
      _EndPtr,
      _Radix,
      _Locale,
    );
  }

  late final __wcstoimax_lPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>,
              ffi.Int,
              _locale_t)>>('_wcstoimax_l');
  late final __wcstoimax_l = __wcstoimax_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>,
          int, _locale_t)>();

  int wcstoumax(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _EndPtr,
    int _Radix,
  ) {
    return _wcstoumax(
      _String,
      _EndPtr,
      _Radix,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int _wcstoumax_l(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _EndPtr,
    int _Radix,
    _locale_t _Locale,
  ) {
    return __wcstoumax_l(
      _String,
      _EndPtr,
      _Radix,
      _Locale,
    );
  }

  late final __wcstoumax_lPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>,
              ffi.Int,
              _locale_t)>>('_wcstoumax_l');
  late final __wcstoumax_l = __wcstoumax_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>,
          int, _locale_t)>();

  /// Is this an error handle?
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsError(
    Object handle,
  ) {
    return _Dart_IsError(
      handle,
    );
  }

  late final _Dart_IsErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsError');
  late final _Dart_IsError =
      _Dart_IsErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an api error handle?
  ///
  /// Api error handles are produced when an api function is misused.
  /// This happens when a Dart embedding api function is called with
  /// invalid arguments or in an invalid context.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsApiError(
    Object handle,
  ) {
    return _Dart_IsApiError(
      handle,
    );
  }

  late final _Dart_IsApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsApiError');
  late final _Dart_IsApiError =
      _Dart_IsApiErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an unhandled exception error handle?
  ///
  /// Unhandled exception error handles are produced when, during the
  /// execution of Dart code, an exception is thrown but not caught.
  /// This can occur in any function which triggers the execution of Dart
  /// code.
  ///
  /// See Dart_ErrorGetException and Dart_ErrorGetStackTrace.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsUnhandledExceptionError(
    Object handle,
  ) {
    return _Dart_IsUnhandledExceptionError(
      handle,
    );
  }

  late final _Dart_IsUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsUnhandledExceptionError');
  late final _Dart_IsUnhandledExceptionError =
      _Dart_IsUnhandledExceptionErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a compilation error handle?
  ///
  /// Compilation error handles are produced when, during the execution
  /// of Dart code, a compile-time error occurs.  This can occur in any
  /// function which triggers the execution of Dart code.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsCompilationError(
    Object handle,
  ) {
    return _Dart_IsCompilationError(
      handle,
    );
  }

  late final _Dart_IsCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsCompilationError');
  late final _Dart_IsCompilationError =
      _Dart_IsCompilationErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a fatal error handle?
  ///
  /// Fatal error handles are produced when the system wants to shut down
  /// the current isolate.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsFatalError(
    Object handle,
  ) {
    return _Dart_IsFatalError(
      handle,
    );
  }

  late final _Dart_IsFatalErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFatalError');
  late final _Dart_IsFatalError =
      _Dart_IsFatalErrorPtr.asFunction<bool Function(Object)>();

  /// Gets the error message from an error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A C string containing an error message if the handle is
  /// error. An empty C string ("") if the handle is valid. This C
  /// String is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_GetError(
    Object handle,
  ) {
    return _Dart_GetError(
      handle,
    );
  }

  late final _Dart_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>(
          'Dart_GetError');
  late final _Dart_GetError =
      _Dart_GetErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(Object)>();

  /// Is this an error handle for an unhandled exception?
  bool Dart_ErrorHasException(
    Object handle,
  ) {
    return _Dart_ErrorHasException(
      handle,
    );
  }

  late final _Dart_ErrorHasExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_ErrorHasException');
  late final _Dart_ErrorHasException =
      _Dart_ErrorHasExceptionPtr.asFunction<bool Function(Object)>();

  /// Gets the exception Object from an unhandled exception error handle.
  Object Dart_ErrorGetException(
    Object handle,
  ) {
    return _Dart_ErrorGetException(
      handle,
    );
  }

  late final _Dart_ErrorGetExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetException');
  late final _Dart_ErrorGetException =
      _Dart_ErrorGetExceptionPtr.asFunction<Object Function(Object)>();

  /// Gets the stack trace Object from an unhandled exception error handle.
  Object Dart_ErrorGetStackTrace(
    Object handle,
  ) {
    return _Dart_ErrorGetStackTrace(
      handle,
    );
  }

  late final _Dart_ErrorGetStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetStackTrace');
  late final _Dart_ErrorGetStackTrace =
      _Dart_ErrorGetStackTracePtr.asFunction<Object Function(Object)>();

  /// Produces an api error handle with the provided error message.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param error the error message.
  Object Dart_NewApiError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewApiError(
      error,
    );
  }

  late final _Dart_NewApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewApiError');
  late final _Dart_NewApiError =
      _Dart_NewApiErrorPtr.asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  Object Dart_NewCompilationError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewCompilationError(
      error,
    );
  }

  late final _Dart_NewCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewCompilationError');
  late final _Dart_NewCompilationError = _Dart_NewCompilationErrorPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Produces a new unhandled exception error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param exception An instance of a Dart object to be thrown or
  /// an ApiError or CompilationError handle.
  /// When an ApiError or CompilationError handle is passed in
  /// a string object of the error message is created and it becomes
  /// the Dart object to be thrown.
  Object Dart_NewUnhandledExceptionError(
    Object exception,
  ) {
    return _Dart_NewUnhandledExceptionError(
      exception,
    );
  }

  late final _Dart_NewUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewUnhandledExceptionError');
  late final _Dart_NewUnhandledExceptionError =
      _Dart_NewUnhandledExceptionErrorPtr.asFunction<Object Function(Object)>();

  /// Propagates an error.
  ///
  /// If the provided handle is an unhandled exception error, this
  /// function will cause the unhandled exception to be rethrown.  This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If the error is not an unhandled exception error, we will unwind
  /// the stack to the next C frame.  Intervening Dart frames will be
  /// discarded; specifically, 'finally' blocks will not execute.  This
  /// is the standard way that compilation errors (and the like) are
  /// handled by the Dart runtime.
  ///
  /// In either case, when an error is propagated any current scopes
  /// created by Dart_EnterScope will be exited.
  ///
  /// See the additional discussion under "Propagating Errors" at the
  /// beginning of this file.
  ///
  /// \param handle An error handle (See Dart_IsError)
  ///
  /// On success, this function does not return.  On failure, the
  /// process is terminated.
  void Dart_PropagateError(
    Object handle,
  ) {
    return _Dart_PropagateError(
      handle,
    );
  }

  late final _Dart_PropagateErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_PropagateError');
  late final _Dart_PropagateError =
      _Dart_PropagateErrorPtr.asFunction<void Function(Object)>();

  /// Converts an object to a string.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return The converted string if no error occurs during
  /// the conversion. If an error does occur, an error handle is
  /// returned.
  Object Dart_ToString(
    Object object,
  ) {
    return _Dart_ToString(
      object,
    );
  }

  late final _Dart_ToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ToString');
  late final _Dart_ToString =
      _Dart_ToStringPtr.asFunction<Object Function(Object)>();

  /// Checks to see if two handles refer to identically equal objects.
  ///
  /// If both handles refer to instances, this is equivalent to using the top-level
  /// function identical() from dart:core. Otherwise, returns whether the two
  /// argument handles refer to the same object.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  ///
  /// \return True if the objects are identically equal.  False otherwise.
  bool Dart_IdentityEquals(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_IdentityEquals(
      obj1,
      obj2,
    );
  }

  late final _Dart_IdentityEqualsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle, ffi.Handle)>>(
          'Dart_IdentityEquals');
  late final _Dart_IdentityEquals =
      _Dart_IdentityEqualsPtr.asFunction<bool Function(Object, Object)>();

  /// Allocates a handle in the current scope from a persistent handle.
  Object Dart_HandleFromPersistent(
    Object object,
  ) {
    return _Dart_HandleFromPersistent(
      object,
    );
  }

  late final _Dart_HandleFromPersistentPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_HandleFromPersistent');
  late final _Dart_HandleFromPersistent =
      _Dart_HandleFromPersistentPtr.asFunction<Object Function(Object)>();

  /// Allocates a handle in the current scope from a weak persistent handle.
  ///
  /// This will be a handle to Dart_Null if the object has been garbage collected.
  Object Dart_HandleFromWeakPersistent(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_HandleFromWeakPersistent(
      object,
    );
  }

  late final _Dart_HandleFromWeakPersistentPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>(
      'Dart_HandleFromWeakPersistent');
  late final _Dart_HandleFromWeakPersistent = _Dart_HandleFromWeakPersistentPtr
      .asFunction<Object Function(Dart_WeakPersistentHandle)>();

  /// Allocates a persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate unless it is
  /// explicitly deallocated by calling Dart_DeletePersistentHandle.
  ///
  /// Requires there to be a current isolate.
  Object Dart_NewPersistentHandle(
    Object object,
  ) {
    return _Dart_NewPersistentHandle(
      object,
    );
  }

  late final _Dart_NewPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewPersistentHandle');
  late final _Dart_NewPersistentHandle =
      _Dart_NewPersistentHandlePtr.asFunction<Object Function(Object)>();

  /// Assign value of local handle to a persistent handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param obj1 A persistent handle whose value needs to be set.
  /// \param obj2 An object whose value needs to be set to the persistent handle.
  void Dart_SetPersistentHandle(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_SetPersistentHandle(
      obj1,
      obj2,
    );
  }

  late final _Dart_SetPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>(
          'Dart_SetPersistentHandle');
  late final _Dart_SetPersistentHandle =
      _Dart_SetPersistentHandlePtr.asFunction<void Function(Object, Object)>();

  /// Deallocates a persistent handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeletePersistentHandle(
    Object object,
  ) {
    return _Dart_DeletePersistentHandle(
      object,
    );
  }

  late final _Dart_DeletePersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_DeletePersistentHandle');
  late final _Dart_DeletePersistentHandle =
      _Dart_DeletePersistentHandlePtr.asFunction<void Function(Object)>();

  /// Allocates a weak persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate. The handle can also be
  /// explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the peer as
  /// argument. The callback can be executed on any thread, will have a current
  /// isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This
  /// gives the embedder the ability to cleanup data associated with the object.
  /// The handle will point to the Dart_Null object after the finalizer has been
  /// run. It is illegal to call into the VM with any other Dart_* functions from
  /// the callback. If the handle is deleted before the object becomes
  /// unreachable, the callback is never invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The weak persistent handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_WeakPersistentHandle Dart_NewWeakPersistentHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewWeakPersistentHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewWeakPersistentHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_WeakPersistentHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewWeakPersistentHandle');
  late final _Dart_NewWeakPersistentHandle =
      _Dart_NewWeakPersistentHandlePtr.asFunction<
          Dart_WeakPersistentHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given weak persistent [object] handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeleteWeakPersistentHandle(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_DeleteWeakPersistentHandle(
      object,
    );
  }

  late final _Dart_DeleteWeakPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>(
          'Dart_DeleteWeakPersistentHandle');
  late final _Dart_DeleteWeakPersistentHandle =
      _Dart_DeleteWeakPersistentHandlePtr.asFunction<
          void Function(Dart_WeakPersistentHandle)>();

  /// Allocates a finalizable handle for an object.
  ///
  /// This handle has the lifetime of the current isolate group unless the object
  /// pointed to by the handle is garbage collected, in this case the VM
  /// automatically deletes the handle after invoking the callback associated
  /// with the handle. The handle can also be explicitly deallocated by
  /// calling Dart_DeleteFinalizableHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the
  /// the peer as argument. The callback can be executed on any thread, will have
  /// an isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.
  /// This gives the embedder the ability to cleanup data associated with the
  /// object and clear out any cached references to the handle. All references to
  /// this handle after the callback will be invalid. It is illegal to call into
  /// the VM with any other Dart_* functions from the callback. If the handle is
  /// deleted before the object becomes unreachable, the callback is never
  /// invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The finalizable handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_FinalizableHandle Dart_NewFinalizableHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewFinalizableHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_FinalizableHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, Dart_HandleFinalizer)>>('Dart_NewFinalizableHandle');
  late final _Dart_NewFinalizableHandle =
      _Dart_NewFinalizableHandlePtr.asFunction<
          Dart_FinalizableHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given finalizable [object] handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// Requires there to be a current isolate.
  void Dart_DeleteFinalizableHandle(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
  ) {
    return _Dart_DeleteFinalizableHandle(
      object,
      strong_ref_to_object,
    );
  }

  late final _Dart_DeleteFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle,
              ffi.Handle)>>('Dart_DeleteFinalizableHandle');
  late final _Dart_DeleteFinalizableHandle = _Dart_DeleteFinalizableHandlePtr
      .asFunction<void Function(Dart_FinalizableHandle, Object)>();

  /// Gets the version string for the Dart VM.
  ///
  /// The version of the Dart VM can be accessed without initializing the VM.
  ///
  /// \return The version string for the embedded Dart VM.
  ffi.Pointer<ffi.Char> Dart_VersionString() {
    return _Dart_VersionString();
  }

  late final _Dart_VersionStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_VersionString');
  late final _Dart_VersionString =
      _Dart_VersionStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize Dart_IsolateFlags with correct version and default values.
  void Dart_IsolateFlagsInitialize(
    ffi.Pointer<Dart_IsolateFlags> flags,
  ) {
    return _Dart_IsolateFlagsInitialize(
      flags,
    );
  }

  late final _Dart_IsolateFlagsInitializePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<Dart_IsolateFlags>)>>(
      'Dart_IsolateFlagsInitialize');
  late final _Dart_IsolateFlagsInitialize = _Dart_IsolateFlagsInitializePtr
      .asFunction<void Function(ffi.Pointer<Dart_IsolateFlags>)>();

  /// Initializes the VM.
  ///
  /// \param params A struct containing initialization information. The version
  /// field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  ///
  /// \return NULL if initialization is successful. Returns an error message
  /// otherwise. The caller is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_Initialize(
    ffi.Pointer<Dart_InitializeParams> params,
  ) {
    return _Dart_Initialize(
      params,
    );
  }

  late final _Dart_InitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Dart_InitializeParams>)>>('Dart_Initialize');
  late final _Dart_Initialize = _Dart_InitializePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<Dart_InitializeParams>)>();

  /// Cleanup state in the VM before process termination.
  ///
  /// \return NULL if cleanup is successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This function must not be called on a thread that was created by the VM
  /// itself.
  ffi.Pointer<ffi.Char> Dart_Cleanup() {
    return _Dart_Cleanup();
  }

  late final _Dart_CleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_Cleanup');
  late final _Dart_Cleanup =
      _Dart_CleanupPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Sets command line flags. Should be called before Dart_Initialize.
  ///
  /// \param argc The length of the arguments array.
  /// \param argv An array of arguments.
  ///
  /// \return NULL if successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This call does not store references to the passed in c-strings.
  ffi.Pointer<ffi.Char> Dart_SetVMFlags(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _Dart_SetVMFlags(
      argc,
      argv,
    );
  }

  late final _Dart_SetVMFlagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_SetVMFlags');
  late final _Dart_SetVMFlags = _Dart_SetVMFlagsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns true if the named VM flag is of boolean type, specified, and set to
  /// true.
  ///
  /// \param flag_name The name of the flag without leading punctuation
  /// (example: "enable_asserts").
  bool Dart_IsVMFlagSet(
    ffi.Pointer<ffi.Char> flag_name,
  ) {
    return _Dart_IsVMFlagSet(
      flag_name,
    );
  }

  late final _Dart_IsVMFlagSetPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_IsVMFlagSet');
  late final _Dart_IsVMFlagSet =
      _Dart_IsVMFlagSetPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a new isolate. The new isolate becomes the current isolate.
  ///
  /// A snapshot can be used to restore the VM quickly to a saved state
  /// and is useful for fast startup. If snapshot data is provided, the
  /// isolate will be started using that snapshot data. Requires a core snapshot or
  /// an app snapshot created by Dart_CreateSnapshot or
  /// Dart_CreatePrecompiledSnapshot* from a VM with the same version.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI
  /// that allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param isolate_snapshot_data Buffer containing the snapshot data of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffer must
  /// remain valid until the isolate shuts down.
  /// \param isolate_snapshot_instructions Buffer containing the snapshot
  /// instructions of the isolate or NULL if no snapshot is provided. If
  /// provided, the buffer must remain valid until the isolate shuts down.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroup(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_data,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_instructions,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroup(
      script_uri,
      name,
      isolate_snapshot_data,
      isolate_snapshot_instructions,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupPtr = _lookup<
      ffi.NativeFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_CreateIsolateGroup');
  late final _Dart_CreateIsolateGroup = _Dart_CreateIsolateGroupPtr.asFunction<
      Dart_Isolate Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<Dart_IsolateFlags>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate inside the isolate group of [group_member].
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param group_member An isolate from the same group into which the newly created
  /// isolate should be born into. Other threads may not have entered / enter this
  /// member isolate.
  /// \param name A short name for the isolate for debugging purposes.
  /// \param shutdown_callback A callback to be called when the isolate is being
  /// shutdown (may be NULL).
  /// \param cleanup_callback A callback to be called when the isolate is being
  /// cleaned up (may be NULL).
  /// \param child_isolate_data The embedder-specific data associated with this isolate.
  /// \param error Set to NULL if creation is successful, set to an error
  /// message otherwise. The caller is responsible for calling free() on the
  /// error message.
  ///
  /// \return The newly created isolate on success, or NULL if isolate creation
  /// failed.
  ///
  /// If successful, the newly created isolate will become the current isolate.
  Dart_Isolate Dart_CreateIsolateInGroup(
    Dart_Isolate group_member,
    ffi.Pointer<ffi.Char> name,
    Dart_IsolateShutdownCallback shutdown_callback,
    Dart_IsolateCleanupCallback cleanup_callback,
    ffi.Pointer<ffi.Void> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateInGroup(
      group_member,
      name,
      shutdown_callback,
      cleanup_callback,
      child_isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateInGroupPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  Dart_Isolate,
                  ffi.Pointer<ffi.Char>,
                  Dart_IsolateShutdownCallback,
                  Dart_IsolateCleanupCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateInGroup');
  late final _Dart_CreateIsolateInGroup =
      _Dart_CreateIsolateInGroupPtr.asFunction<
          Dart_Isolate Function(
              Dart_Isolate,
              ffi.Pointer<ffi.Char>,
              Dart_IsolateShutdownCallback,
              Dart_IsolateCleanupCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate from a Dart Kernel file. The new isolate
  /// becomes the current isolate.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI that
  /// allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param kernel_buffer A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  /// \param kernel_buffer_size The size of `kernel_buffer`.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroupFromKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroupFromKernel(
      script_uri,
      name,
      kernel_buffer,
      kernel_buffer_size,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupFromKernelPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.IntPtr,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateGroupFromKernel');
  late final _Dart_CreateIsolateGroupFromKernel =
      _Dart_CreateIsolateGroupFromKernelPtr.asFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Shuts down the current isolate. After this call, the current isolate is NULL.
  /// Any current scopes created by Dart_EnterScope will be exited. Invokes the
  /// shutdown callback and any callbacks of remaining weak persistent handles.
  ///
  /// Requires there to be a current isolate.
  void Dart_ShutdownIsolate() {
    return _Dart_ShutdownIsolate();
  }

  late final _Dart_ShutdownIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ShutdownIsolate');
  late final _Dart_ShutdownIsolate =
      _Dart_ShutdownIsolatePtr.asFunction<void Function()>();

  /// Returns the current isolate. Will return NULL if there is no
  /// current isolate.
  Dart_Isolate Dart_CurrentIsolate() {
    return _Dart_CurrentIsolate();
  }

  late final _Dart_CurrentIsolatePtr =
      _lookup<ffi.NativeFunction<Dart_Isolate Function()>>(
          'Dart_CurrentIsolate');
  late final _Dart_CurrentIsolate =
      _Dart_CurrentIsolatePtr.asFunction<Dart_Isolate Function()>();

  /// Returns the callback data associated with the current isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateData() {
    return _Dart_CurrentIsolateData();
  }

  late final _Dart_CurrentIsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateData');
  late final _Dart_CurrentIsolateData = _Dart_CurrentIsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function()>();

  /// Returns the callback data associated with the given isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_IsolateData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateData(
      isolate,
    );
  }

  late final _Dart_IsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateData');
  late final _Dart_IsolateData = _Dart_IsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the current isolate group. Will return NULL if there is no
  /// current isolate group.
  Dart_IsolateGroup Dart_CurrentIsolateGroup() {
    return _Dart_CurrentIsolateGroup();
  }

  late final _Dart_CurrentIsolateGroupPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroup Function()>>(
          'Dart_CurrentIsolateGroup');
  late final _Dart_CurrentIsolateGroup =
      _Dart_CurrentIsolateGroupPtr.asFunction<Dart_IsolateGroup Function()>();

  /// Returns the callback data associated with the current isolate group. This
  /// data was passed to the isolate group when it was created.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateGroupData() {
    return _Dart_CurrentIsolateGroupData();
  }

  late final _Dart_CurrentIsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateGroupData');
  late final _Dart_CurrentIsolateGroupData = _Dart_CurrentIsolateGroupDataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  int Dart_CurrentIsolateGroupId() {
    return _Dart_CurrentIsolateGroupId();
  }

  late final _Dart_CurrentIsolateGroupIdPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroupId Function()>>(
          'Dart_CurrentIsolateGroupId');
  late final _Dart_CurrentIsolateGroupId =
      _Dart_CurrentIsolateGroupIdPtr.asFunction<int Function()>();

  /// Returns the callback data associated with the specified isolate group. This
  /// data was passed to the isolate when it was created.
  /// The embedder is responsible for ensuring the consistency of this data
  /// with respect to the lifecycle of an isolate group.
  ffi.Pointer<ffi.Void> Dart_IsolateGroupData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateGroupData(
      isolate,
    );
  }

  late final _Dart_IsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateGroupData');
  late final _Dart_IsolateGroupData = _Dart_IsolateGroupDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  Object Dart_DebugName() {
    return _Dart_DebugName();
  }

  late final _Dart_DebugNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_DebugName');
  late final _Dart_DebugName =
      _Dart_DebugNamePtr.asFunction<Object Function()>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  ///
  /// The returned string is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_DebugNameToCString() {
    return _Dart_DebugNameToCString();
  }

  late final _Dart_DebugNameToCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_DebugNameToCString');
  late final _Dart_DebugNameToCString = _Dart_DebugNameToCStringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function()>();

  /// Returns the ID for an isolate which is used to query the service protocol.
  ///
  /// It is the responsibility of the caller to free the returned ID.
  ffi.Pointer<ffi.Char> Dart_IsolateServiceId(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateServiceId(
      isolate,
    );
  }

  late final _Dart_IsolateServiceIdPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateServiceId');
  late final _Dart_IsolateServiceId = _Dart_IsolateServiceIdPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Enters an isolate. After calling this function,
  /// the current isolate will be set to the provided isolate.
  ///
  /// Requires there to be no current isolate. Multiple threads may not be in
  /// the same isolate at once.
  void Dart_EnterIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_EnterIsolate(
      isolate,
    );
  }

  late final _Dart_EnterIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_EnterIsolate');
  late final _Dart_EnterIsolate =
      _Dart_EnterIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Kills the given isolate.
  ///
  /// This function has the same effect as dart:isolate's
  /// Isolate.kill(priority:immediate).
  /// It can interrupt ordinary Dart code but not native code. If the isolate is
  /// in the middle of a long running native function, the isolate will not be
  /// killed until control returns to Dart.
  ///
  /// Does not require a current isolate. It is safe to kill the current isolate if
  /// there is one.
  void Dart_KillIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_KillIsolate(
      isolate,
    );
  }

  late final _Dart_KillIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_KillIsolate');
  late final _Dart_KillIsolate =
      _Dart_KillIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Notifies the VM that the embedder expects to be idle until |deadline|. The VM
  /// may use this time to perform garbage collection or other tasks to avoid
  /// delays during execution of Dart code in the future.
  ///
  /// |deadline| is measured in microseconds against the system's monotonic time.
  /// This clock can be accessed via Dart_TimelineGetMicros().
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyIdle(
    int deadline,
  ) {
    return _Dart_NotifyIdle(
      deadline,
    );
  }

  late final _Dart_NotifyIdlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'Dart_NotifyIdle');
  late final _Dart_NotifyIdle =
      _Dart_NotifyIdlePtr.asFunction<void Function(int)>();

  /// Starts the heap sampling profiler for each thread in the VM.
  void Dart_EnableHeapSampling() {
    return _Dart_EnableHeapSampling();
  }

  late final _Dart_EnableHeapSamplingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_EnableHeapSampling');
  late final _Dart_EnableHeapSampling =
      _Dart_EnableHeapSamplingPtr.asFunction<void Function()>();

  void Dart_DisableHeapSampling() {
    return _Dart_DisableHeapSampling();
  }

  late final _Dart_DisableHeapSamplingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_DisableHeapSampling');
  late final _Dart_DisableHeapSampling =
      _Dart_DisableHeapSamplingPtr.asFunction<void Function()>();

  void Dart_RegisterHeapSamplingCallback(
    Dart_HeapSamplingCreateCallback create_callback,
    Dart_HeapSamplingDeleteCallback delete_callback,
  ) {
    return _Dart_RegisterHeapSamplingCallback(
      create_callback,
      delete_callback,
    );
  }

  late final _Dart_RegisterHeapSamplingCallbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Dart_HeapSamplingCreateCallback,
                  Dart_HeapSamplingDeleteCallback)>>(
      'Dart_RegisterHeapSamplingCallback');
  late final _Dart_RegisterHeapSamplingCallback =
      _Dart_RegisterHeapSamplingCallbackPtr.asFunction<
          void Function(Dart_HeapSamplingCreateCallback,
              Dart_HeapSamplingDeleteCallback)>();

  void Dart_ReportSurvivingAllocations(
    Dart_HeapSamplingReportCallback callback,
    ffi.Pointer<ffi.Void> context,
    bool force_gc,
  ) {
    return _Dart_ReportSurvivingAllocations(
      callback,
      context,
      force_gc,
    );
  }

  late final _Dart_ReportSurvivingAllocationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_HeapSamplingReportCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool)>>('Dart_ReportSurvivingAllocations');
  late final _Dart_ReportSurvivingAllocations =
      _Dart_ReportSurvivingAllocationsPtr.asFunction<
          void Function(
              Dart_HeapSamplingReportCallback, ffi.Pointer<ffi.Void>, bool)>();

  void Dart_SetHeapSamplingPeriod(
    int bytes,
  ) {
    return _Dart_SetHeapSamplingPeriod(
      bytes,
    );
  }

  late final _Dart_SetHeapSamplingPeriodPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.IntPtr)>>(
          'Dart_SetHeapSamplingPeriod');
  late final _Dart_SetHeapSamplingPeriod =
      _Dart_SetHeapSamplingPeriodPtr.asFunction<void Function(int)>();

  /// Notifies the VM that the embedder expects the application's working set has
  /// recently shrunk significantly and is not expected to rise in the near future.
  /// The VM may spend O(heap-size) time performing clean up work.
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyDestroyed() {
    return _Dart_NotifyDestroyed();
  }

  late final _Dart_NotifyDestroyedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyDestroyed');
  late final _Dart_NotifyDestroyed =
      _Dart_NotifyDestroyedPtr.asFunction<void Function()>();

  /// Notifies the VM that the system is running low on memory.
  ///
  /// Does not require a current isolate. Only valid after calling Dart_Initialize.
  void Dart_NotifyLowMemory() {
    return _Dart_NotifyLowMemory();
  }

  late final _Dart_NotifyLowMemoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyLowMemory');
  late final _Dart_NotifyLowMemory =
      _Dart_NotifyLowMemoryPtr.asFunction<void Function()>();

  /// Set the desired performance trade-off.
  ///
  /// Requires a current isolate.
  ///
  /// Returns the previous performance mode.
  int Dart_SetPerformanceMode(
    int mode,
  ) {
    return _Dart_SetPerformanceMode(
      mode,
    );
  }

  late final _Dart_SetPerformanceModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'Dart_SetPerformanceMode');
  late final _Dart_SetPerformanceMode =
      _Dart_SetPerformanceModePtr.asFunction<int Function(int)>();

  /// Starts the CPU sampling profiler.
  void Dart_StartProfiling() {
    return _Dart_StartProfiling();
  }

  late final _Dart_StartProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StartProfiling');
  late final _Dart_StartProfiling =
      _Dart_StartProfilingPtr.asFunction<void Function()>();

  /// Stops the CPU sampling profiler.
  ///
  /// Note that some profile samples might still be taken after this function
  /// returns due to the asynchronous nature of the implementation on some
  /// platforms.
  void Dart_StopProfiling() {
    return _Dart_StopProfiling();
  }

  late final _Dart_StopProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StopProfiling');
  late final _Dart_StopProfiling =
      _Dart_StopProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should not be profiled until a
  /// matching call to Dart_ThreadEnableProfiling is made.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  /// This function should be used when an embedder knows a thread is about
  /// to make a blocking call and wants to avoid unnecessary interrupts by
  /// the profiler.
  void Dart_ThreadDisableProfiling() {
    return _Dart_ThreadDisableProfiling();
  }

  late final _Dart_ThreadDisableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadDisableProfiling');
  late final _Dart_ThreadDisableProfiling =
      _Dart_ThreadDisableProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should be profiled.
  ///
  /// NOTE: It is only legal to call this function *after* calling
  /// Dart_ThreadDisableProfiling.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  void Dart_ThreadEnableProfiling() {
    return _Dart_ThreadEnableProfiling();
  }

  late final _Dart_ThreadEnableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadEnableProfiling');
  late final _Dart_ThreadEnableProfiling =
      _Dart_ThreadEnableProfilingPtr.asFunction<void Function()>();

  /// Register symbol information for the Dart VM's profiler and crash dumps.
  ///
  /// This consumes the output of //topaz/runtime/dart/profiler_symbols, which
  /// should be treated as opaque.
  void Dart_AddSymbols(
    ffi.Pointer<ffi.Char> dso_name,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_size,
  ) {
    return _Dart_AddSymbols(
      dso_name,
      buffer,
      buffer_size,
    );
  }

  late final _Dart_AddSymbolsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_AddSymbols');
  late final _Dart_AddSymbols = _Dart_AddSymbolsPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)>();

  /// Exits an isolate. After this call, Dart_CurrentIsolate will
  /// return NULL.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitIsolate() {
    return _Dart_ExitIsolate();
  }

  late final _Dart_ExitIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitIsolate');
  late final _Dart_ExitIsolate =
      _Dart_ExitIsolatePtr.asFunction<void Function()>();

  /// Creates a full snapshot of the current isolate heap.
  ///
  /// A full snapshot is a compact representation of the dart vm isolate heap
  /// and dart isolate heap states. These snapshots are used to initialize
  /// the vm isolate on startup and fast initialization of an isolate.
  /// A Snapshot of the heap is created before any dart code has executed.
  ///
  /// Requires there to be a current isolate. Not available in the precompiled
  /// runtime (check Dart_IsPrecompiledRuntime).
  ///
  /// \param vm_snapshot_data_buffer Returns a pointer to a buffer containing the
  /// vm snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param vm_snapshot_data_size Returns the size of vm_snapshot_data_buffer.
  /// \param isolate_snapshot_data_buffer Returns a pointer to a buffer containing
  /// the isolate snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param isolate_snapshot_data_size Returns the size of
  /// isolate_snapshot_data_buffer.
  /// \param is_core Create a snapshot containing core libraries.
  /// Such snapshot should be agnostic to null safety mode.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateSnapshot(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    bool is_core,
  ) {
    return _Dart_CreateSnapshot(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      is_core,
    );
  }

  late final _Dart_CreateSnapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Bool)>>('Dart_CreateSnapshot');
  late final _Dart_CreateSnapshot = _Dart_CreateSnapshotPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          bool)>();

  /// Returns whether the buffer contains a kernel file.
  ///
  /// \param buffer Pointer to a buffer that might contain a kernel binary.
  /// \param buffer_size Size of the buffer.
  ///
  /// \return Whether the buffer contains a kernel binary (full or partial).
  bool Dart_IsKernel(
    ffi.Pointer<ffi.Uint8> buffer,
    int buffer_size,
  ) {
    return _Dart_IsKernel(
      buffer,
      buffer_size,
    );
  }

  late final _Dart_IsKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_IsKernel');
  late final _Dart_IsKernel = _Dart_IsKernelPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Make isolate runnable.
  ///
  /// When isolates are spawned, this function is used to indicate that
  /// the creation and initialization (including script loading) of the
  /// isolate is complete and the isolate can start.
  /// This function expects there to be no current isolate.
  ///
  /// \param isolate The isolate to be made runnable.
  ///
  /// \return NULL if successful. Returns an error message otherwise. The caller
  /// is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_IsolateMakeRunnable(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateMakeRunnable(
      isolate,
    );
  }

  late final _Dart_IsolateMakeRunnablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateMakeRunnable');
  late final _Dart_IsolateMakeRunnable = _Dart_IsolateMakeRunnablePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Allows embedders to provide a custom wakeup mechanism for the delivery of
  /// inter-isolate messages. This setting only applies to the current isolate.
  ///
  /// This mechanism is optional: if not provided, the isolate will be scheduled on
  /// a VM-managed thread pool. An embedder should provide this callback if it
  /// wants to run an isolate on a specific thread or to interleave handling of
  /// inter-isolate messages with other event sources.
  ///
  /// Most embedders will only call this function once, before isolate
  /// execution begins. If this function is called after isolate
  /// execution begins, the embedder is responsible for threading issues.
  void Dart_SetMessageNotifyCallback(
    Dart_MessageNotifyCallback message_notify_callback,
  ) {
    return _Dart_SetMessageNotifyCallback(
      message_notify_callback,
    );
  }

  late final _Dart_SetMessageNotifyCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Dart_MessageNotifyCallback)>>(
      'Dart_SetMessageNotifyCallback');
  late final _Dart_SetMessageNotifyCallback = _Dart_SetMessageNotifyCallbackPtr
      .asFunction<void Function(Dart_MessageNotifyCallback)>();

  /// Query the current message notify callback for the isolate.
  ///
  /// \return The current message notify callback for the isolate.
  Dart_MessageNotifyCallback Dart_GetMessageNotifyCallback() {
    return _Dart_GetMessageNotifyCallback();
  }

  late final _Dart_GetMessageNotifyCallbackPtr =
      _lookup<ffi.NativeFunction<Dart_MessageNotifyCallback Function()>>(
          'Dart_GetMessageNotifyCallback');
  late final _Dart_GetMessageNotifyCallback = _Dart_GetMessageNotifyCallbackPtr
      .asFunction<Dart_MessageNotifyCallback Function()>();

  /// If the VM flag `--pause-isolates-on-start` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on start was requested.
  bool Dart_ShouldPauseOnStart() {
    return _Dart_ShouldPauseOnStart();
  }

  late final _Dart_ShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnStart');
  late final _Dart_ShouldPauseOnStart =
      _Dart_ShouldPauseOnStartPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-start` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on start?
  ///
  /// NOTE: This must be called before Dart_IsolateMakeRunnable.
  void Dart_SetShouldPauseOnStart(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnStart(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnStart');
  late final _Dart_SetShouldPauseOnStart =
      _Dart_SetShouldPauseOnStartPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on start?
  ///
  /// \return A boolean value indicating if the isolate is paused on start.
  bool Dart_IsPausedOnStart() {
    return _Dart_IsPausedOnStart();
  }

  late final _Dart_IsPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnStart');
  late final _Dart_IsPausedOnStart =
      _Dart_IsPausedOnStartPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on start and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on start?
  void Dart_SetPausedOnStart(
    bool paused,
  ) {
    return _Dart_SetPausedOnStart(
      paused,
    );
  }

  late final _Dart_SetPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnStart');
  late final _Dart_SetPausedOnStart =
      _Dart_SetPausedOnStartPtr.asFunction<void Function(bool)>();

  /// If the VM flag `--pause-isolates-on-exit` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on exit was requested.
  bool Dart_ShouldPauseOnExit() {
    return _Dart_ShouldPauseOnExit();
  }

  late final _Dart_ShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnExit');
  late final _Dart_ShouldPauseOnExit =
      _Dart_ShouldPauseOnExitPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-exit` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on exit?
  void Dart_SetShouldPauseOnExit(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnExit(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnExit');
  late final _Dart_SetShouldPauseOnExit =
      _Dart_SetShouldPauseOnExitPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on exit?
  ///
  /// \return A boolean value indicating if the isolate is paused on exit.
  bool Dart_IsPausedOnExit() {
    return _Dart_IsPausedOnExit();
  }

  late final _Dart_IsPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnExit');
  late final _Dart_IsPausedOnExit =
      _Dart_IsPausedOnExitPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on exit and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on exit?
  void Dart_SetPausedOnExit(
    bool paused,
  ) {
    return _Dart_SetPausedOnExit(
      paused,
    );
  }

  late final _Dart_SetPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnExit');
  late final _Dart_SetPausedOnExit =
      _Dart_SetPausedOnExitPtr.asFunction<void Function(bool)>();

  /// Called when the embedder has caught a top level unhandled exception error
  /// in the current isolate.
  ///
  /// NOTE: It is illegal to call this twice on the same isolate without first
  /// clearing the sticky error to null.
  ///
  /// \param error The unhandled exception error.
  void Dart_SetStickyError(
    Object error,
  ) {
    return _Dart_SetStickyError(
      error,
    );
  }

  late final _Dart_SetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_SetStickyError');
  late final _Dart_SetStickyError =
      _Dart_SetStickyErrorPtr.asFunction<void Function(Object)>();

  /// Does the current isolate have a sticky error?
  bool Dart_HasStickyError() {
    return _Dart_HasStickyError();
  }

  late final _Dart_HasStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasStickyError');
  late final _Dart_HasStickyError =
      _Dart_HasStickyErrorPtr.asFunction<bool Function()>();

  /// Gets the sticky error for the current isolate.
  ///
  /// \return A handle to the sticky error object or null.
  Object Dart_GetStickyError() {
    return _Dart_GetStickyError();
  }

  late final _Dart_GetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_GetStickyError');
  late final _Dart_GetStickyError =
      _Dart_GetStickyErrorPtr.asFunction<Object Function()>();

  /// Handles the next pending message for the current isolate.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_HandleMessage() {
    return _Dart_HandleMessage();
  }

  late final _Dart_HandleMessagePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_HandleMessage');
  late final _Dart_HandleMessage =
      _Dart_HandleMessagePtr.asFunction<Object Function()>();

  /// Drains the microtask queue, then blocks the calling thread until the current
  /// isolate receives a message, then handles all messages.
  ///
  /// \param timeout_millis When non-zero, the call returns after the indicated
  /// number of milliseconds even if no message was received.
  /// \return A valid handle if no error occurs, otherwise an error handle.
  Object Dart_WaitForEvent(
    int timeout_millis,
  ) {
    return _Dart_WaitForEvent(
      timeout_millis,
    );
  }

  late final _Dart_WaitForEventPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_WaitForEvent');
  late final _Dart_WaitForEvent =
      _Dart_WaitForEventPtr.asFunction<Object Function(int)>();

  /// Handles any pending messages for the vm service for the current
  /// isolate.
  ///
  /// This function may be used by an embedder at a breakpoint to avoid
  /// pausing the vm service.
  ///
  /// This function can indirectly cause the message notify callback to
  /// be called.
  ///
  /// \return true if the vm service requests the program resume
  /// execution, false otherwise
  bool Dart_HandleServiceMessages() {
    return _Dart_HandleServiceMessages();
  }

  late final _Dart_HandleServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HandleServiceMessages');
  late final _Dart_HandleServiceMessages =
      _Dart_HandleServiceMessagesPtr.asFunction<bool Function()>();

  /// Does the current isolate have pending service messages?
  ///
  /// \return true if the isolate has pending service messages, false otherwise.
  bool Dart_HasServiceMessages() {
    return _Dart_HasServiceMessages();
  }

  late final _Dart_HasServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HasServiceMessages');
  late final _Dart_HasServiceMessages =
      _Dart_HasServiceMessagesPtr.asFunction<bool Function()>();

  /// Processes any incoming messages for the current isolate.
  ///
  /// This function may only be used when the embedder has not provided
  /// an alternate message delivery mechanism with
  /// Dart_SetMessageCallbacks. It is provided for convenience.
  ///
  /// This function waits for incoming messages for the current
  /// isolate. As new messages arrive, they are handled using
  /// Dart_HandleMessage. The routine exits when all ports to the
  /// current isolate are closed.
  ///
  /// \return A valid handle if the run loop exited successfully.  If an
  /// exception or other error occurs while processing messages, an
  /// error handle is returned.
  Object Dart_RunLoop() {
    return _Dart_RunLoop();
  }

  late final _Dart_RunLoopPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RunLoop');
  late final _Dart_RunLoop = _Dart_RunLoopPtr.asFunction<Object Function()>();

  /// Lets the VM run message processing for the isolate.
  ///
  /// This function expects there to a current isolate and the current isolate
  /// must not have an active api scope. The VM will take care of making the
  /// isolate runnable (if not already), handles its message loop and will take
  /// care of shutting the isolate down once it's done.
  ///
  /// \param errors_are_fatal Whether uncaught errors should be fatal.
  /// \param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).
  /// \param on_exit_port A port to notify on exit (or ILLEGAL_PORT).
  /// \param error A non-NULL pointer which will hold an error message if the call
  /// fails. The error has to be free()ed by the caller.
  ///
  /// \return If successful the VM takes ownership of the isolate and takes care
  /// of its message loop. If not successful the caller retains ownership of the
  /// isolate.
  bool Dart_RunLoopAsync(
    bool errors_are_fatal,
    int on_error_port,
    int on_exit_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_RunLoopAsync(
      errors_are_fatal,
      on_error_port,
      on_exit_port,
      error,
    );
  }

  late final _Dart_RunLoopAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Bool, Dart_Port, Dart_Port,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_RunLoopAsync');
  late final _Dart_RunLoopAsync = _Dart_RunLoopAsyncPtr.asFunction<
      bool Function(bool, int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets the main port id for the current isolate.
  int Dart_GetMainPortId() {
    return _Dart_GetMainPortId();
  }

  late final _Dart_GetMainPortIdPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_GetMainPortId');
  late final _Dart_GetMainPortId =
      _Dart_GetMainPortIdPtr.asFunction<int Function()>();

  /// Does the current isolate have live ReceivePorts?
  ///
  /// A ReceivePort is live when it has not been closed.
  bool Dart_HasLivePorts() {
    return _Dart_HasLivePorts();
  }

  late final _Dart_HasLivePortsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasLivePorts');
  late final _Dart_HasLivePorts =
      _Dart_HasLivePortsPtr.asFunction<bool Function()>();

  /// Posts a message for some isolate. The message is a serialized
  /// object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// For posting messages outside of an isolate see \ref Dart_PostCObject.
  ///
  /// \param port_id The destination port.
  /// \param object An object from the current isolate.
  ///
  /// \return True if the message was posted.
  bool Dart_Post(
    int port_id,
    Object object,
  ) {
    return _Dart_Post(
      port_id,
      object,
    );
  }

  late final _Dart_PostPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Handle)>>(
          'Dart_Post');
  late final _Dart_Post =
      _Dart_PostPtr.asFunction<bool Function(int, Object)>();

  /// Returns a new SendPort with the provided port id.
  ///
  /// \param port_id The destination port.
  ///
  /// \return A new SendPort if no errors occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewSendPort(
    int port_id,
  ) {
    return _Dart_NewSendPort(
      port_id,
    );
  }

  late final _Dart_NewSendPortPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_Port)>>(
          'Dart_NewSendPort');
  late final _Dart_NewSendPort =
      _Dart_NewSendPortPtr.asFunction<Object Function(int)>();

  /// Gets the SendPort id for the provided SendPort.
  /// \param port A SendPort object whose id is desired.
  /// \param port_id Returns the id of the SendPort.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_SendPortGetId(
    Object port,
    ffi.Pointer<Dart_Port> port_id,
  ) {
    return _Dart_SendPortGetId(
      port,
      port_id,
    );
  }

  late final _Dart_SendPortGetIdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<Dart_Port>)>>('Dart_SendPortGetId');
  late final _Dart_SendPortGetId = _Dart_SendPortGetIdPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_Port>)>();

  /// Enters a new scope.
  ///
  /// All new local handles will be created in this scope. Additionally,
  /// some functions may return "scope allocated" memory which is only
  /// valid within this scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_EnterScope() {
    return _Dart_EnterScope();
  }

  late final _Dart_EnterScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_EnterScope');
  late final _Dart_EnterScope =
      _Dart_EnterScopePtr.asFunction<void Function()>();

  /// Exits a scope.
  ///
  /// The previous scope (if any) becomes the current scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitScope() {
    return _Dart_ExitScope();
  }

  late final _Dart_ExitScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitScope');
  late final _Dart_ExitScope = _Dart_ExitScopePtr.asFunction<void Function()>();

  /// The Dart VM uses "zone allocation" for temporary structures. Zones
  /// support very fast allocation of small chunks of memory. The chunks
  /// cannot be deallocated individually, but instead zones support
  /// deallocating all chunks in one fast operation.
  ///
  /// This function makes it possible for the embedder to allocate
  /// temporary data in the VMs zone allocator.
  ///
  /// Zone allocation is possible:
  /// 1. when inside a scope where local handles can be allocated
  /// 2. when processing a message from a native port in a native port
  /// handler
  ///
  /// All the memory allocated this way will be reclaimed either on the
  /// next call to Dart_ExitScope or when the native port handler exits.
  ///
  /// \param size Size of the memory to allocate.
  ///
  /// \return A pointer to the allocated memory. NULL if allocation
  /// failed. Failure might due to is no current VM zone.
  ffi.Pointer<ffi.Uint8> Dart_ScopeAllocate(
    int size,
  ) {
    return _Dart_ScopeAllocate(
      size,
    );
  }

  late final _Dart_ScopeAllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr)>>(
          'Dart_ScopeAllocate');
  late final _Dart_ScopeAllocate =
      _Dart_ScopeAllocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  /// Returns the null object.
  ///
  /// \return A handle to the null object.
  Object Dart_Null() {
    return _Dart_Null();
  }

  late final _Dart_NullPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Null');
  late final _Dart_Null = _Dart_NullPtr.asFunction<Object Function()>();

  /// Is this object null?
  bool Dart_IsNull(
    Object object,
  ) {
    return _Dart_IsNull(
      object,
    );
  }

  late final _Dart_IsNullPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsNull');
  late final _Dart_IsNull = _Dart_IsNullPtr.asFunction<bool Function(Object)>();

  /// Returns the empty string object.
  ///
  /// \return A handle to the empty string object.
  Object Dart_EmptyString() {
    return _Dart_EmptyString();
  }

  late final _Dart_EmptyStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_EmptyString');
  late final _Dart_EmptyString =
      _Dart_EmptyStringPtr.asFunction<Object Function()>();

  /// Returns types that are not classes, and which therefore cannot be looked up
  /// as library members by Dart_GetType.
  ///
  /// \return A handle to the dynamic, void or Never type.
  Object Dart_TypeDynamic() {
    return _Dart_TypeDynamic();
  }

  late final _Dart_TypeDynamicPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeDynamic');
  late final _Dart_TypeDynamic =
      _Dart_TypeDynamicPtr.asFunction<Object Function()>();

  Object Dart_TypeVoid() {
    return _Dart_TypeVoid();
  }

  late final _Dart_TypeVoidPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeVoid');
  late final _Dart_TypeVoid = _Dart_TypeVoidPtr.asFunction<Object Function()>();

  Object Dart_TypeNever() {
    return _Dart_TypeNever();
  }

  late final _Dart_TypeNeverPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeNever');
  late final _Dart_TypeNever =
      _Dart_TypeNeverPtr.asFunction<Object Function()>();

  /// Checks if the two objects are equal.
  ///
  /// The result of the comparison is returned through the 'equal'
  /// parameter. The return value itself is used to indicate success or
  /// failure, not equality.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  /// \param equal Returns the result of the equality comparison.
  ///
  /// \return A valid handle if no error occurs during the comparison.
  Object Dart_ObjectEquals(
    Object obj1,
    Object obj2,
    ffi.Pointer<ffi.Bool> equal,
  ) {
    return _Dart_ObjectEquals(
      obj1,
      obj2,
      equal,
    );
  }

  late final _Dart_ObjectEqualsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectEquals');
  late final _Dart_ObjectEquals = _Dart_ObjectEqualsPtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object an instance of some type?
  ///
  /// The result of the test is returned through the 'instanceof' parameter.
  /// The return value itself is used to indicate success or failure.
  ///
  /// \param object An object.
  /// \param type A type.
  /// \param instanceof Return true if 'object' is an instance of type 'type'.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ObjectIsType(
    Object object,
    Object type,
    ffi.Pointer<ffi.Bool> instanceof,
  ) {
    return _Dart_ObjectIsType(
      object,
      type,
      instanceof,
    );
  }

  late final _Dart_ObjectIsTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectIsType');
  late final _Dart_ObjectIsType = _Dart_ObjectIsTypePtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Query object type.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is of the specified type.
  bool Dart_IsInstance(
    Object object,
  ) {
    return _Dart_IsInstance(
      object,
    );
  }

  late final _Dart_IsInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInstance');
  late final _Dart_IsInstance =
      _Dart_IsInstancePtr.asFunction<bool Function(Object)>();

  bool Dart_IsNumber(
    Object object,
  ) {
    return _Dart_IsNumber(
      object,
    );
  }

  late final _Dart_IsNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsNumber');
  late final _Dart_IsNumber =
      _Dart_IsNumberPtr.asFunction<bool Function(Object)>();

  bool Dart_IsInteger(
    Object object,
  ) {
    return _Dart_IsInteger(
      object,
    );
  }

  late final _Dart_IsIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInteger');
  late final _Dart_IsInteger =
      _Dart_IsIntegerPtr.asFunction<bool Function(Object)>();

  bool Dart_IsDouble(
    Object object,
  ) {
    return _Dart_IsDouble(
      object,
    );
  }

  late final _Dart_IsDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsDouble');
  late final _Dart_IsDouble =
      _Dart_IsDoublePtr.asFunction<bool Function(Object)>();

  bool Dart_IsBoolean(
    Object object,
  ) {
    return _Dart_IsBoolean(
      object,
    );
  }

  late final _Dart_IsBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsBoolean');
  late final _Dart_IsBoolean =
      _Dart_IsBooleanPtr.asFunction<bool Function(Object)>();

  bool Dart_IsString(
    Object object,
  ) {
    return _Dart_IsString(
      object,
    );
  }

  late final _Dart_IsStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsString');
  late final _Dart_IsString =
      _Dart_IsStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsStringLatin1(
    Object object,
  ) {
    return _Dart_IsStringLatin1(
      object,
    );
  }

  late final _Dart_IsStringLatin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsStringLatin1');
  late final _Dart_IsStringLatin1 =
      _Dart_IsStringLatin1Ptr.asFunction<bool Function(Object)>();

  bool Dart_IsExternalString(
    Object object,
  ) {
    return _Dart_IsExternalString(
      object,
    );
  }

  late final _Dart_IsExternalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsExternalString');
  late final _Dart_IsExternalString =
      _Dart_IsExternalStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsList(
    Object object,
  ) {
    return _Dart_IsList(
      object,
    );
  }

  late final _Dart_IsListPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsList');
  late final _Dart_IsList = _Dart_IsListPtr.asFunction<bool Function(Object)>();

  bool Dart_IsMap(
    Object object,
  ) {
    return _Dart_IsMap(
      object,
    );
  }

  late final _Dart_IsMapPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsMap');
  late final _Dart_IsMap = _Dart_IsMapPtr.asFunction<bool Function(Object)>();

  bool Dart_IsLibrary(
    Object object,
  ) {
    return _Dart_IsLibrary(
      object,
    );
  }

  late final _Dart_IsLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsLibrary');
  late final _Dart_IsLibrary =
      _Dart_IsLibraryPtr.asFunction<bool Function(Object)>();

  bool Dart_IsType(
    Object handle,
  ) {
    return _Dart_IsType(
      handle,
    );
  }

  late final _Dart_IsTypePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsType');
  late final _Dart_IsType = _Dart_IsTypePtr.asFunction<bool Function(Object)>();

  bool Dart_IsFunction(
    Object handle,
  ) {
    return _Dart_IsFunction(
      handle,
    );
  }

  late final _Dart_IsFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFunction');
  late final _Dart_IsFunction =
      _Dart_IsFunctionPtr.asFunction<bool Function(Object)>();

  bool Dart_IsVariable(
    Object handle,
  ) {
    return _Dart_IsVariable(
      handle,
    );
  }

  late final _Dart_IsVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsVariable');
  late final _Dart_IsVariable =
      _Dart_IsVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypeVariable(
    Object handle,
  ) {
    return _Dart_IsTypeVariable(
      handle,
    );
  }

  late final _Dart_IsTypeVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypeVariable');
  late final _Dart_IsTypeVariable =
      _Dart_IsTypeVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsClosure(
    Object object,
  ) {
    return _Dart_IsClosure(
      object,
    );
  }

  late final _Dart_IsClosurePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsClosure');
  late final _Dart_IsClosure =
      _Dart_IsClosurePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypedData(
    Object object,
  ) {
    return _Dart_IsTypedData(
      object,
    );
  }

  late final _Dart_IsTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypedData');
  late final _Dart_IsTypedData =
      _Dart_IsTypedDataPtr.asFunction<bool Function(Object)>();

  bool Dart_IsByteBuffer(
    Object object,
  ) {
    return _Dart_IsByteBuffer(
      object,
    );
  }

  late final _Dart_IsByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsByteBuffer');
  late final _Dart_IsByteBuffer =
      _Dart_IsByteBufferPtr.asFunction<bool Function(Object)>();

  bool Dart_IsFuture(
    Object object,
  ) {
    return _Dart_IsFuture(
      object,
    );
  }

  late final _Dart_IsFuturePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFuture');
  late final _Dart_IsFuture =
      _Dart_IsFuturePtr.asFunction<bool Function(Object)>();

  /// Gets the type of a Dart language object.
  ///
  /// \param instance Some Dart object.
  ///
  /// \return If no error occurs, the type is returned. Otherwise an
  /// error handle is returned.
  Object Dart_InstanceGetType(
    Object instance,
  ) {
    return _Dart_InstanceGetType(
      instance,
    );
  }

  late final _Dart_InstanceGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_InstanceGetType');
  late final _Dart_InstanceGetType =
      _Dart_InstanceGetTypePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided class type.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_ClassName(
    Object cls_type,
  ) {
    return _Dart_ClassName(
      cls_type,
    );
  }

  late final _Dart_ClassNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassName');
  late final _Dart_ClassName =
      _Dart_ClassNamePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided function or method.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_FunctionName(
    Object function,
  ) {
    return _Dart_FunctionName(
      function,
    );
  }

  late final _Dart_FunctionNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionName');
  late final _Dart_FunctionName =
      _Dart_FunctionNamePtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the owner of a function.
  ///
  /// The owner of an instance method or a static method is its defining
  /// class. The owner of a top-level function is its defining
  /// library. The owner of the function of a non-implicit closure is the
  /// function of the method or closure that defines the non-implicit
  /// closure.
  ///
  /// \return A valid handle to the owner of the function, or an error
  /// handle if the argument is not a valid handle to a function.
  Object Dart_FunctionOwner(
    Object function,
  ) {
    return _Dart_FunctionOwner(
      function,
    );
  }

  late final _Dart_FunctionOwnerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionOwner');
  late final _Dart_FunctionOwner =
      _Dart_FunctionOwnerPtr.asFunction<Object Function(Object)>();

  /// Determines whether a function handle refers to a static function
  /// of method.
  ///
  /// For the purposes of the embedding API, a top-level function is
  /// implicitly declared static.
  ///
  /// \param function A handle to a function or method declaration.
  /// \param is_static Returns whether the function or method is declared static.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_FunctionIsStatic(
    Object function,
    ffi.Pointer<ffi.Bool> is_static,
  ) {
    return _Dart_FunctionIsStatic(
      function,
      is_static,
    );
  }

  late final _Dart_FunctionIsStaticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_FunctionIsStatic');
  late final _Dart_FunctionIsStatic = _Dart_FunctionIsStaticPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object a closure resulting from a tear-off (closurized method)?
  ///
  /// Returns true for closures produced when an ordinary method is accessed
  /// through a getter call. Returns false otherwise, in particular for closures
  /// produced from local function declarations.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is a tear-off.
  bool Dart_IsTearOff(
    Object object,
  ) {
    return _Dart_IsTearOff(
      object,
    );
  }

  late final _Dart_IsTearOffPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTearOff');
  late final _Dart_IsTearOff =
      _Dart_IsTearOffPtr.asFunction<bool Function(Object)>();

  /// Retrieves the function of a closure.
  ///
  /// \return A handle to the function of the closure, or an error handle if the
  /// argument is not a closure.
  Object Dart_ClosureFunction(
    Object closure,
  ) {
    return _Dart_ClosureFunction(
      closure,
    );
  }

  late final _Dart_ClosureFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClosureFunction');
  late final _Dart_ClosureFunction =
      _Dart_ClosureFunctionPtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the library which contains class.
  ///
  /// \return A valid handle to the library with owns class, null if the class
  /// has no library or an error handle if the argument is not a valid handle
  /// to a class type.
  Object Dart_ClassLibrary(
    Object cls_type,
  ) {
    return _Dart_ClassLibrary(
      cls_type,
    );
  }

  late final _Dart_ClassLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassLibrary');
  late final _Dart_ClassLibrary =
      _Dart_ClassLibraryPtr.asFunction<Object Function(Object)>();

  /// Does this Integer fit into a 64-bit signed integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit signed integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoInt64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoInt64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoInt64');
  late final _Dart_IntegerFitsIntoInt64 = _Dart_IntegerFitsIntoInt64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Does this Integer fit into a 64-bit unsigned integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit unsigned integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoUint64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoUint64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoUint64');
  late final _Dart_IntegerFitsIntoUint64 = _Dart_IntegerFitsIntoUint64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewInteger(
    int value,
  ) {
    return _Dart_NewInteger(
      value,
    );
  }

  late final _Dart_NewIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_NewInteger');
  late final _Dart_NewInteger =
      _Dart_NewIntegerPtr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The unsigned value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromUint64(
    int value,
  ) {
    return _Dart_NewIntegerFromUint64(
      value,
    );
  }

  late final _Dart_NewIntegerFromUint64Ptr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Uint64)>>(
          'Dart_NewIntegerFromUint64');
  late final _Dart_NewIntegerFromUint64 =
      _Dart_NewIntegerFromUint64Ptr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer represented as a C string
  /// containing a hexadecimal number.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromHexCString(
    ffi.Pointer<ffi.Char> value,
  ) {
    return _Dart_NewIntegerFromHexCString(
      value,
    );
  }

  late final _Dart_NewIntegerFromHexCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewIntegerFromHexCString');
  late final _Dart_NewIntegerFromHexCString = _Dart_NewIntegerFromHexCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit signed integer, otherwise an error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToInt64(
    Object integer,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_IntegerToInt64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Int64>)>>('Dart_IntegerToInt64');
  late final _Dart_IntegerToInt64 = _Dart_IntegerToInt64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Int64>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit unsigned integer, otherwise an
  /// error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToUint64(
    Object integer,
    ffi.Pointer<ffi.Uint64> value,
  ) {
    return _Dart_IntegerToUint64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Uint64>)>>('Dart_IntegerToUint64');
  late final _Dart_IntegerToUint64 = _Dart_IntegerToUint64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Uint64>)>();

  /// Gets the value of an integer as a hexadecimal C string.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer as a hexadecimal C
  /// string. This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToHexCString(
    Object integer,
    ffi.Pointer<ffi.Pointer<ffi.Char>> value,
  ) {
    return _Dart_IntegerToHexCString(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToHexCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_IntegerToHexCString');
  late final _Dart_IntegerToHexCString =
      _Dart_IntegerToHexCStringPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns a Double with the provided value.
  ///
  /// \param value A double.
  ///
  /// \return The Double object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewDouble(
    double value,
  ) {
    return _Dart_NewDouble(
      value,
    );
  }

  late final _Dart_NewDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Double)>>(
          'Dart_NewDouble');
  late final _Dart_NewDouble =
      _Dart_NewDoublePtr.asFunction<Object Function(double)>();

  /// Gets the value of a Double
  ///
  /// \param double_obj A Double
  /// \param value Returns the value of the Double.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_DoubleValue(
    Object double_obj,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_DoubleValue(
      double_obj,
      value,
    );
  }

  late final _Dart_DoubleValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Double>)>>('Dart_DoubleValue');
  late final _Dart_DoubleValue = _Dart_DoubleValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Double>)>();

  /// Returns a closure of static function 'function_name' in the class 'class_name'
  /// in the exported namespace of specified 'library'.
  ///
  /// \param library Library object
  /// \param cls_type Type object representing a Class
  /// \param function_name Name of the static function in the class
  ///
  /// \return A valid Dart instance if no error occurs during the operation.
  Object Dart_GetStaticMethodClosure(
    Object library1,
    Object cls_type,
    Object function_name,
  ) {
    return _Dart_GetStaticMethodClosure(
      library1,
      cls_type,
      function_name,
    );
  }

  late final _Dart_GetStaticMethodClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Handle)>>('Dart_GetStaticMethodClosure');
  late final _Dart_GetStaticMethodClosure = _Dart_GetStaticMethodClosurePtr
      .asFunction<Object Function(Object, Object, Object)>();

  /// Returns the True object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the True object.
  Object Dart_True() {
    return _Dart_True();
  }

  late final _Dart_TruePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_True');
  late final _Dart_True = _Dart_TruePtr.asFunction<Object Function()>();

  /// Returns the False object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the False object.
  Object Dart_False() {
    return _Dart_False();
  }

  late final _Dart_FalsePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_False');
  late final _Dart_False = _Dart_FalsePtr.asFunction<Object Function()>();

  /// Returns a Boolean with the provided value.
  ///
  /// \param value true or false.
  ///
  /// \return The Boolean object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewBoolean(
    bool value,
  ) {
    return _Dart_NewBoolean(
      value,
    );
  }

  late final _Dart_NewBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_NewBoolean');
  late final _Dart_NewBoolean =
      _Dart_NewBooleanPtr.asFunction<Object Function(bool)>();

  /// Gets the value of a Boolean
  ///
  /// \param boolean_obj A Boolean
  /// \param value Returns the value of the Boolean.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_BooleanValue(
    Object boolean_obj,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_BooleanValue(
      boolean_obj,
      value,
    );
  }

  late final _Dart_BooleanValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_BooleanValue');
  late final _Dart_BooleanValue = _Dart_BooleanValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Gets the length of a String.
  ///
  /// \param str A String.
  /// \param length Returns the length of the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringLength(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringLength(
      str,
      length,
    );
  }

  late final _Dart_StringLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringLength');
  late final _Dart_StringLength = _Dart_StringLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the length of UTF-8 encoded representation for a string.
  ///
  /// \param str A String.
  /// \param length Returns the length of UTF-8 encoded representation for string.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringUTF8Length(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringUTF8Length(
      str,
      length,
    );
  }

  late final _Dart_StringUTF8LengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringUTF8Length');
  late final _Dart_StringUTF8Length = _Dart_StringUTF8LengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns a String built from the provided C string
  /// (There is an implicit assumption that the C string passed in contains
  /// UTF-8 encoded characters and '\0' is considered as a termination
  /// character).
  ///
  /// \param str A C String
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromCString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _Dart_NewStringFromCString(
      str,
    );
  }

  late final _Dart_NewStringFromCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewStringFromCString');
  late final _Dart_NewStringFromCString = _Dart_NewStringFromCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Returns a String built from an array of UTF-8 encoded characters.
  ///
  /// \param utf8_array An array of UTF-8 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF8(
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF8(
      utf8_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_NewStringFromUTF8');
  late final _Dart_NewStringFromUTF8 = _Dart_NewStringFromUTF8Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns a String built from an array of UTF-16 encoded characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF16(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF16(
      utf16_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>, ffi.IntPtr)>>('Dart_NewStringFromUTF16');
  late final _Dart_NewStringFromUTF16 = _Dart_NewStringFromUTF16Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint16>, int)>();

  /// Returns a String built from an array of UTF-32 encoded characters.
  ///
  /// \param utf32_array An array of UTF-32 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF32(
    ffi.Pointer<ffi.Int32> utf32_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF32(
      utf32_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr)>>('Dart_NewStringFromUTF32');
  late final _Dart_NewStringFromUTF32 = _Dart_NewStringFromUTF32Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Int32>, int)>();

  /// Returns a String which references an external array of
  /// Latin-1 (ISO-8859-1) encoded characters.
  ///
  /// \param latin1_array Array of Latin-1 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalLatin1String(
    ffi.Pointer<ffi.Uint8> latin1_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalLatin1String(
      latin1_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalLatin1StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalLatin1String');
  late final _Dart_NewExternalLatin1String =
      _Dart_NewExternalLatin1StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Returns a String which references an external array of UTF-16 encoded
  /// characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalUTF16String(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalUTF16String(
      utf16_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalUTF16StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalUTF16String');
  late final _Dart_NewExternalUTF16String =
      _Dart_NewExternalUTF16StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint16>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Gets the C string representation of a String.
  /// (It is a sequence of UTF-8 encoded values with a '\0' termination.)
  ///
  /// \param str A string.
  /// \param cstr Returns the String represented as a C string.
  /// This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToCString(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> cstr,
  ) {
    return _Dart_StringToCString(
      str,
      cstr,
    );
  }

  late final _Dart_StringToCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_StringToCString');
  late final _Dart_StringToCString = _Dart_StringToCStringPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets a UTF-8 encoded representation of a String.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need
  /// to preserve unpaired surrogates, use the Dart_StringToUTF16 function.
  ///
  /// \param str A string.
  /// \param utf8_array Returns the String represented as UTF-8 code
  /// units.  This UTF-8 array is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param length Used to return the length of the array which was
  /// actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF8(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> utf8_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF8(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_StringToUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF8');
  late final _Dart_StringToUTF8 = _Dart_StringToUTF8Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>)>();

  /// Copies the UTF-8 encoded representation of a String into specified buffer.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8).
  ///
  /// \param str A string.
  /// \param utf8_array Buffer into which the UTF-8 encoded representation of
  /// the string is copied into.
  /// The buffer is allocated and managed by the caller.
  /// \param length Specifies the length of the buffer passed in.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CopyUTF8EncodingOfString(
    Object str,
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_CopyUTF8EncodingOfString(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_CopyUTF8EncodingOfStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_CopyUTF8EncodingOfString');
  late final _Dart_CopyUTF8EncodingOfString = _Dart_CopyUTF8EncodingOfStringPtr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the data corresponding to the string object. This function returns
  /// the data only for Latin-1 (ISO-8859-1) string objects. For all other
  /// string objects it returns an error.
  ///
  /// \param str A string.
  /// \param latin1_array An array allocated by the caller, used to return
  /// the string data.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToLatin1(
    Object str,
    ffi.Pointer<ffi.Uint8> latin1_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToLatin1(
      str,
      latin1_array,
      length,
    );
  }

  late final _Dart_StringToLatin1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToLatin1');
  late final _Dart_StringToLatin1 = _Dart_StringToLatin1Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the UTF-16 encoded representation of a string.
  ///
  /// \param str A string.
  /// \param utf16_array An array allocated by the caller, used to return
  /// the array of UTF-16 encoded characters.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF16(
    Object str,
    ffi.Pointer<ffi.Uint16> utf16_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF16(
      str,
      utf16_array,
      length,
    );
  }

  late final _Dart_StringToUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF16');
  late final _Dart_StringToUTF16 = _Dart_StringToUTF16Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the storage size in bytes of a String.
  ///
  /// \param str A String.
  /// \param size Returns the storage size in bytes of the String.
  /// This is the size in bytes needed to store the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringStorageSize(
    Object str,
    ffi.Pointer<ffi.IntPtr> size,
  ) {
    return _Dart_StringStorageSize(
      str,
      size,
    );
  }

  late final _Dart_StringStorageSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringStorageSize');
  late final _Dart_StringStorageSize = _Dart_StringStorageSizePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Retrieves some properties associated with a String.
  /// Properties retrieved are:
  /// - character size of the string (one or two byte)
  /// - length of the string
  /// - peer pointer of string if it is an external string.
  /// \param str A String.
  /// \param char_size Returns the character size of the String.
  /// \param str_len Returns the length of the String.
  /// \param peer Returns the peer pointer associated with the String or 0 if
  /// there is no peer pointer for it.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_StringGetProperties(
    Object str,
    ffi.Pointer<ffi.IntPtr> char_size,
    ffi.Pointer<ffi.IntPtr> str_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_StringGetProperties(
      str,
      char_size,
      str_len,
      peer,
    );
  }

  late final _Dart_StringGetPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_StringGetProperties');
  late final _Dart_StringGetProperties =
      _Dart_StringGetPropertiesPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Returns a List<dynamic> of the desired length.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewList(
    int length,
  ) {
    return _Dart_NewList(
      length,
    );
  }

  late final _Dart_NewListPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_NewList');
  late final _Dart_NewList =
      _Dart_NewListPtr.asFunction<Object Function(int)>();

  /// Returns a List of the desired length with the desired legacy element type.
  ///
  /// \param element_type_id The type of elements of the list.
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns an error
  /// handle.
  Object Dart_NewListOf(
    int element_type_id,
    int length,
  ) {
    return _Dart_NewListOf(
      element_type_id,
      length,
    );
  }

  late final _Dart_NewListOfPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewListOf');
  late final _Dart_NewListOf =
      _Dart_NewListOfPtr.asFunction<Object Function(int, int)>();

  /// Returns a List of the desired length with the desired element type.
  ///
  /// \param element_type Handle to a nullable type object. E.g., from
  /// Dart_GetType or Dart_GetNullableType.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfType(
    Object element_type,
    int length,
  ) {
    return _Dart_NewListOfType(
      element_type,
      length,
    );
  }

  late final _Dart_NewListOfTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_NewListOfType');
  late final _Dart_NewListOfType =
      _Dart_NewListOfTypePtr.asFunction<Object Function(Object, int)>();

  /// Returns a List of the desired length with the desired element type, filled
  /// with the provided object.
  ///
  /// \param element_type Handle to a type object. E.g., from Dart_GetType.
  ///
  /// \param fill_object Handle to an object of type 'element_type' that will be
  /// used to populate the list. This parameter can only be Dart_Null() if the
  /// length of the list is 0 or 'element_type' is a nullable type.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfTypeFilled(
    Object element_type,
    Object fill_object,
    int length,
  ) {
    return _Dart_NewListOfTypeFilled(
      element_type,
      fill_object,
      length,
    );
  }

  late final _Dart_NewListOfTypeFilledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.IntPtr)>>('Dart_NewListOfTypeFilled');
  late final _Dart_NewListOfTypeFilled = _Dart_NewListOfTypeFilledPtr
      .asFunction<Object Function(Object, Object, int)>();

  /// Gets the length of a List.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param length Returns the length of the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListLength(
    Object list,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_ListLength(
      list,
      length,
    );
  }

  late final _Dart_ListLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_ListLength');
  late final _Dart_ListLength = _Dart_ListLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  ///
  /// \return The Object in the List at the specified index if no error
  /// occurs. Otherwise returns an error handle.
  Object Dart_ListGetAt(
    Object list,
    int index,
  ) {
    return _Dart_ListGetAt(
      list,
      index,
    );
  }

  late final _Dart_ListGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_ListGetAt');
  late final _Dart_ListGetAt =
      _Dart_ListGetAtPtr.asFunction<Object Function(Object, int)>();

  /// Gets a range of Objects from a List.
  ///
  /// If any of the requested index values are out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param offset The offset of the first item to get.
  /// \param length The number of items to get.
  /// \param result A pointer to fill with the objects.
  ///
  /// \return Success if no error occurs during the operation.
  Object Dart_ListGetRange(
    Object list,
    int offset,
    int length,
    ffi.Pointer<ffi.Handle> result,
  ) {
    return _Dart_ListGetRange(
      list,
      offset,
      length,
      result,
    );
  }

  late final _Dart_ListGetRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_ListGetRange');
  late final _Dart_ListGetRange = _Dart_ListGetRangePtr.asFunction<
      Object Function(Object, int, int, ffi.Pointer<ffi.Handle>)>();

  /// Sets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  /// \param value The Object to put in the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListSetAt(
    Object list,
    int index,
    Object value,
  ) {
    return _Dart_ListSetAt(
      list,
      index,
      value,
    );
  }

  late final _Dart_ListSetAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.IntPtr, ffi.Handle)>>('Dart_ListSetAt');
  late final _Dart_ListSetAt =
      _Dart_ListSetAtPtr.asFunction<Object Function(Object, int, Object)>();

  /// May generate an unhandled exception error.
  Object Dart_ListGetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListGetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListGetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListGetAsBytes');
  late final _Dart_ListGetAsBytes = _Dart_ListGetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// May generate an unhandled exception error.
  Object Dart_ListSetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListSetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListSetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListSetAsBytes');
  late final _Dart_ListSetAsBytes = _Dart_ListSetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the Object at some key of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  /// \param key An Object.
  ///
  /// \return The value in the map at the specified key, null if the map does not
  /// contain the key, or an error handle.
  Object Dart_MapGetAt(
    Object map,
    Object key,
  ) {
    return _Dart_MapGetAt(
      map,
      key,
    );
  }

  late final _Dart_MapGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapGetAt');
  late final _Dart_MapGetAt =
      _Dart_MapGetAtPtr.asFunction<Object Function(Object, Object)>();

  /// Returns whether the Map contains a given key.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return A handle on a boolean indicating whether map contains the key.
  /// Otherwise returns an error handle.
  Object Dart_MapContainsKey(
    Object map,
    Object key,
  ) {
    return _Dart_MapContainsKey(
      map,
      key,
    );
  }

  late final _Dart_MapContainsKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapContainsKey');
  late final _Dart_MapContainsKey =
      _Dart_MapContainsKeyPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the list of keys of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return The list of key Objects if no error occurs. Otherwise returns an
  /// error handle.
  Object Dart_MapKeys(
    Object map,
  ) {
    return _Dart_MapKeys(
      map,
    );
  }

  late final _Dart_MapKeysPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_MapKeys');
  late final _Dart_MapKeys =
      _Dart_MapKeysPtr.asFunction<Object Function(Object)>();

  /// Return type if this object is a TypedData object.
  ///
  /// \return kInvalid if the object is not a TypedData object or the appropriate
  /// Dart_TypedData_Type.
  int Dart_GetTypeOfTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfTypedData');
  late final _Dart_GetTypeOfTypedData =
      _Dart_GetTypeOfTypedDataPtr.asFunction<int Function(Object)>();

  /// Return type if this object is an external TypedData object.
  ///
  /// \return kInvalid if the object is not an external TypedData object or
  /// the appropriate Dart_TypedData_Type.
  int Dart_GetTypeOfExternalTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfExternalTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfExternalTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfExternalTypedData');
  late final _Dart_GetTypeOfExternalTypedData =
      _Dart_GetTypeOfExternalTypedDataPtr.asFunction<int Function(Object)>();

  /// Returns a TypedData object of the desired length and type.
  ///
  /// \param type The type of the TypedData object.
  /// \param length The length of the TypedData object (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewTypedData(
    int type,
    int length,
  ) {
    return _Dart_NewTypedData(
      type,
      length,
    );
  }

  late final _Dart_NewTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewTypedData');
  late final _Dart_NewTypedData =
      _Dart_NewTypedDataPtr.asFunction<Object Function(int, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedData(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _Dart_NewExternalTypedData(
      type,
      data,
      length,
    );
  }

  late final _Dart_NewExternalTypedDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_NewExternalTypedData');
  late final _Dart_NewExternalTypedData = _Dart_NewExternalTypedDataPtr
      .asFunction<Object Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedDataWithFinalizer(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalTypedDataWithFinalizer(
      type,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalTypedDataWithFinalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalTypedDataWithFinalizer');
  late final _Dart_NewExternalTypedDataWithFinalizer =
      _Dart_NewExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  Object Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
      type,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>, ffi.IntPtr,
                  ffi.Pointer<ffi.Void>, ffi.IntPtr, Dart_HandleFinalizer)>>(
      'Dart_NewUnmodifiableExternalTypedDataWithFinalizer');
  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizer =
      _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Returns a ByteBuffer object for the typed data.
  ///
  /// \param typed_data The TypedData object.
  ///
  /// \return The ByteBuffer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewByteBuffer(
    Object typed_data,
  ) {
    return _Dart_NewByteBuffer(
      typed_data,
    );
  }

  late final _Dart_NewByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewByteBuffer');
  late final _Dart_NewByteBuffer =
      _Dart_NewByteBufferPtr.asFunction<Object Function(Object)>();

  /// Acquires access to the internal data address of a TypedData object.
  ///
  /// \param object The typed data object whose internal data address is to
  /// be accessed.
  /// \param type The type of the object is returned here.
  /// \param data The internal data address is returned here.
  /// \param len Size of the typed array is returned here.
  ///
  /// Notes:
  /// When the internal address of the object is acquired any calls to a
  /// Dart API function that could potentially allocate an object or run
  /// any Dart code will return an error.
  ///
  /// Any Dart API functions for accessing the data should not be called
  /// before the corresponding release. In particular, the object should
  /// not be acquired again before its release. This leads to undefined
  /// behavior.
  ///
  /// \return Success if the internal data address is acquired successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataAcquireData(
    Object object,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    ffi.Pointer<ffi.IntPtr> len,
  ) {
    return _Dart_TypedDataAcquireData(
      object,
      type,
      data,
      len,
    );
  }

  late final _Dart_TypedDataAcquireDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_TypedDataAcquireData');
  late final _Dart_TypedDataAcquireData =
      _Dart_TypedDataAcquireDataPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Releases access to the internal data address that was acquired earlier using
  /// Dart_TypedDataAcquireData.
  ///
  /// \param object The typed data object whose internal data address is to be
  /// released.
  ///
  /// \return Success if the internal data address is released successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataReleaseData(
    Object object,
  ) {
    return _Dart_TypedDataReleaseData(
      object,
    );
  }

  late final _Dart_TypedDataReleaseDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypedDataReleaseData');
  late final _Dart_TypedDataReleaseData =
      _Dart_TypedDataReleaseDataPtr.asFunction<Object Function(Object)>();

  /// Returns the TypedData object associated with the ByteBuffer object.
  ///
  /// \param byte_buffer The ByteBuffer object.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_GetDataFromByteBuffer(
    Object byte_buffer,
  ) {
    return _Dart_GetDataFromByteBuffer(
      byte_buffer,
    );
  }

  late final _Dart_GetDataFromByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_GetDataFromByteBuffer');
  late final _Dart_GetDataFromByteBuffer =
      _Dart_GetDataFromByteBufferPtr.asFunction<Object Function(Object)>();

  /// Invokes a constructor, creating a new object.
  ///
  /// This function allows hidden constructors (constructors with leading
  /// underscores) to be called.
  ///
  /// \param type Type of object to be constructed.
  /// \param constructor_name The name of the constructor to invoke.  Use
  /// Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// This name should not include the name of the class.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the constructor.
  ///
  /// \return If the constructor is called and completes successfully,
  /// then the new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_New(
    Object type,
    Object constructor_name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_New(
      type,
      constructor_name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_NewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_New');
  late final _Dart_New = _Dart_NewPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Allocate a new object without invoking a constructor.
  ///
  /// \param type The type of an object to be allocated.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_Allocate(
    Object type,
  ) {
    return _Dart_Allocate(
      type,
    );
  }

  late final _Dart_AllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_Allocate');
  late final _Dart_Allocate =
      _Dart_AllocatePtr.asFunction<Object Function(Object)>();

  /// Allocate a new object without invoking a constructor, and sets specified
  /// native fields.
  ///
  /// \param type The type of an object to be allocated.
  /// \param num_native_fields The number of native fields to set.
  /// \param native_fields An array containing the value of native fields.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_AllocateWithNativeFields(
    Object type,
    int num_native_fields,
    ffi.Pointer<ffi.IntPtr> native_fields,
  ) {
    return _Dart_AllocateWithNativeFields(
      type,
      num_native_fields,
      native_fields,
    );
  }

  late final _Dart_AllocateWithNativeFieldsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_AllocateWithNativeFields');
  late final _Dart_AllocateWithNativeFields = _Dart_AllocateWithNativeFieldsPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Invokes a method or function.
  ///
  /// The 'target' parameter may be an object, type, or library.  If
  /// 'target' is an object, then this function will invoke an instance
  /// method.  If 'target' is a type, then this function will invoke a
  /// static method.  If 'target' is a library, then this function will
  /// invoke a top-level function from that library.
  /// NOTE: This API call cannot be used to invoke methods of a type object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param target An object, type, or library.
  /// \param name The name of the function or method to invoke.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the function or method is called and completes
  /// successfully, then the return value is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_Invoke(
    Object target,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_Invoke(
      target,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_Invoke');
  late final _Dart_Invoke = _Dart_InvokePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Closure with the given arguments.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return If no error occurs during execution, then the result of
  /// invoking the closure is returned. If an error occurs during
  /// execution, then an error handle is returned.
  Object Dart_InvokeClosure(
    Object closure,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeClosure(
      closure,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeClosure');
  late final _Dart_InvokeClosure = _Dart_InvokeClosurePtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Generative Constructor on an object that was previously
  /// allocated using Dart_Allocate/Dart_AllocateWithNativeFields.
  ///
  /// The 'object' parameter must be an object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param object An object.
  /// \param name The name of the constructor to invoke.
  /// Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the constructor is called and completes
  /// successfully, then the object is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_InvokeConstructor(
    Object object,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeConstructor(
      object,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeConstructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeConstructor');
  late final _Dart_InvokeConstructor = _Dart_InvokeConstructorPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Gets the value of a field.
  ///
  /// The 'container' parameter may be an object, type, or library.  If
  /// 'container' is an object, then this function will access an
  /// instance field.  If 'container' is a type, then this function will
  /// access a static field.  If 'container' is a library, then this
  /// function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  ///
  /// \return If no error occurs, then the value of the field is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetField(
    Object container,
    Object name,
  ) {
    return _Dart_GetField(
      container,
      name,
    );
  }

  late final _Dart_GetFieldPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetField');
  late final _Dart_GetField =
      _Dart_GetFieldPtr.asFunction<Object Function(Object, Object)>();

  /// Sets the value of a field.
  ///
  /// The 'container' parameter may actually be an object, type, or
  /// library.  If 'container' is an object, then this function will
  /// access an instance field.  If 'container' is a type, then this
  /// function will access a static field.  If 'container' is a library,
  /// then this function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  /// \param value The new field value.
  ///
  /// \return A valid handle if no error occurs.
  Object Dart_SetField(
    Object container,
    Object name,
    Object value,
  ) {
    return _Dart_SetField(
      container,
      name,
      value,
    );
  }

  late final _Dart_SetFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.Handle)>>('Dart_SetField');
  late final _Dart_SetField =
      _Dart_SetFieldPtr.asFunction<Object Function(Object, Object, Object)>();

  /// Throws an exception.
  ///
  /// This function causes a Dart language exception to be thrown. This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If an error handle is passed into this function, the error is
  /// propagated immediately.  See Dart_PropagateError for a discussion
  /// of error propagation.
  ///
  /// If successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ThrowException(
    Object exception,
  ) {
    return _Dart_ThrowException(
      exception,
    );
  }

  late final _Dart_ThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ThrowException');
  late final _Dart_ThrowException =
      _Dart_ThrowExceptionPtr.asFunction<Object Function(Object)>();

  /// Rethrows an exception.
  ///
  /// Rethrows an exception, unwinding all dart frames on the stack. If
  /// successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ReThrowException(
    Object exception,
    Object stacktrace,
  ) {
    return _Dart_ReThrowException(
      exception,
      stacktrace,
    );
  }

  late final _Dart_ReThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_ReThrowException');
  late final _Dart_ReThrowException =
      _Dart_ReThrowExceptionPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the number of native instance fields in an object.
  Object Dart_GetNativeInstanceFieldCount(
    Object obj,
    ffi.Pointer<ffi.Int> count,
  ) {
    return _Dart_GetNativeInstanceFieldCount(
      obj,
      count,
    );
  }

  late final _Dart_GetNativeInstanceFieldCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Int>)>>('Dart_GetNativeInstanceFieldCount');
  late final _Dart_GetNativeInstanceFieldCount =
      _Dart_GetNativeInstanceFieldCountPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int>)>();

  /// Gets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_GetNativeInstanceField(
    Object obj,
    int index,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_GetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeInstanceField');
  late final _Dart_GetNativeInstanceField = _Dart_GetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Sets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetNativeInstanceField(
    Object obj,
    int index,
    int value,
  ) {
    return _Dart_SetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_SetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Int, ffi.IntPtr)>>('Dart_SetNativeInstanceField');
  late final _Dart_SetNativeInstanceField = _Dart_SetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, int)>();

  /// Extracts current isolate group data from the native arguments structure.
  ffi.Pointer<ffi.Void> Dart_GetNativeIsolateGroupData(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeIsolateGroupData(
      args,
    );
  }

  late final _Dart_GetNativeIsolateGroupDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              Dart_NativeArguments)>>('Dart_GetNativeIsolateGroupData');
  late final _Dart_GetNativeIsolateGroupData =
      _Dart_GetNativeIsolateGroupDataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(Dart_NativeArguments)>();

  /// Gets the native arguments based on the types passed in and populates
  /// the passed arguments buffer with appropriate native values.
  ///
  /// \param args the Native arguments block passed into the native call.
  /// \param num_arguments length of argument descriptor array and argument
  /// values array passed in.
  /// \param arg_descriptors an array that describes the arguments that
  /// need to be retrieved. For each argument to be retrieved the descriptor
  /// contains the argument number (0, 1 etc.) and the argument type
  /// described using Dart_NativeArgument_Type, e.g:
  /// DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates
  /// that the first argument is to be retrieved and it should be a boolean.
  /// \param arg_values array into which the native arguments need to be
  /// extracted into, the array is allocated by the caller (it could be
  /// stack allocated to avoid the malloc/free performance overhead).
  ///
  /// \return Success if all the arguments could be extracted correctly,
  /// returns an error handle if there were any errors while extracting the
  /// arguments (mismatched number of arguments, incorrect types, etc.).
  Object Dart_GetNativeArguments(
    Dart_NativeArguments args,
    int num_arguments,
    ffi.Pointer<Dart_NativeArgument_Descriptor> arg_descriptors,
    ffi.Pointer<Dart_NativeArgument_Value> arg_values,
  ) {
    return _Dart_GetNativeArguments(
      args,
      num_arguments,
      arg_descriptors,
      arg_values,
    );
  }

  late final _Dart_GetNativeArgumentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments,
                  ffi.Int,
                  ffi.Pointer<Dart_NativeArgument_Descriptor>,
                  ffi.Pointer<Dart_NativeArgument_Value>)>>(
      'Dart_GetNativeArguments');
  late final _Dart_GetNativeArguments = _Dart_GetNativeArgumentsPtr.asFunction<
      Object Function(
          Dart_NativeArguments,
          int,
          ffi.Pointer<Dart_NativeArgument_Descriptor>,
          ffi.Pointer<Dart_NativeArgument_Value>)>();

  /// Gets the native argument at some index.
  Object Dart_GetNativeArgument(
    Dart_NativeArguments args,
    int index,
  ) {
    return _Dart_GetNativeArgument(
      args,
      index,
    );
  }

  late final _Dart_GetNativeArgumentPtr = _lookup<
          ffi
          .NativeFunction<ffi.Handle Function(Dart_NativeArguments, ffi.Int)>>(
      'Dart_GetNativeArgument');
  late final _Dart_GetNativeArgument = _Dart_GetNativeArgumentPtr.asFunction<
      Object Function(Dart_NativeArguments, int)>();

  /// Gets the number of native arguments.
  int Dart_GetNativeArgumentCount(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeArgumentCount(
      args,
    );
  }

  late final _Dart_GetNativeArgumentCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Dart_NativeArguments)>>(
          'Dart_GetNativeArgumentCount');
  late final _Dart_GetNativeArgumentCount = _Dart_GetNativeArgumentCountPtr
      .asFunction<int Function(Dart_NativeArguments)>();

  /// Gets all the native fields of the native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param num_fields size of the intptr_t array 'field_values' passed in.
  /// \param field_values intptr_t array in which native field values are returned.
  /// \return Success if the native fields where copied in successfully. Otherwise
  /// returns an error handle. On success the native field values are copied
  /// into the 'field_values' array, if the argument at 'arg_index' is a
  /// null object then 0 is copied as the native field values into the
  /// 'field_values' array.
  Object Dart_GetNativeFieldsOfArgument(
    Dart_NativeArguments args,
    int arg_index,
    int num_fields,
    ffi.Pointer<ffi.IntPtr> field_values,
  ) {
    return _Dart_GetNativeFieldsOfArgument(
      args,
      arg_index,
      num_fields,
      field_values,
    );
  }

  late final _Dart_GetNativeFieldsOfArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeFieldsOfArgument');
  late final _Dart_GetNativeFieldsOfArgument =
      _Dart_GetNativeFieldsOfArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the native field of the receiver.
  Object Dart_GetNativeReceiver(
    Dart_NativeArguments args,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeReceiver(
      args,
      value,
    );
  }

  late final _Dart_GetNativeReceiverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeReceiver');
  late final _Dart_GetNativeReceiver = _Dart_GetNativeReceiverPtr.asFunction<
      Object Function(Dart_NativeArguments, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets a string native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param peer Returns the peer pointer if the string argument has one.
  /// \return Success if the string argument has a peer, if it does not
  /// have a peer then the String object is returned. Otherwise returns
  /// an error handle (argument is not a String object).
  Object Dart_GetNativeStringArgument(
    Dart_NativeArguments args,
    int arg_index,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetNativeStringArgument(
      args,
      arg_index,
      peer,
    );
  }

  late final _Dart_GetNativeStringArgumentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'Dart_GetNativeStringArgument');
  late final _Dart_GetNativeStringArgument =
      _Dart_GetNativeStringArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Gets an integer native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the integer value if the argument is an Integer.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeIntegerArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_GetNativeIntegerArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeIntegerArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('Dart_GetNativeIntegerArgument');
  late final _Dart_GetNativeIntegerArgument =
      _Dart_GetNativeIntegerArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Int64>)>();

  /// Gets a boolean native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the boolean value if the argument is a Boolean.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeBooleanArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_GetNativeBooleanArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeBooleanArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Bool>)>>('Dart_GetNativeBooleanArgument');
  late final _Dart_GetNativeBooleanArgument =
      _Dart_GetNativeBooleanArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Bool>)>();

  /// Gets a double native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the double value if the argument is a double.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeDoubleArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_GetNativeDoubleArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeDoubleArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Double>)>>('Dart_GetNativeDoubleArgument');
  late final _Dart_GetNativeDoubleArgument =
      _Dart_GetNativeDoubleArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Double>)>();

  /// Sets the return value for a native function.
  ///
  /// If retval is an Error handle, then error will be propagated once
  /// the native functions exits. See Dart_PropagateError for a
  /// discussion of how different types of errors are propagated.
  void Dart_SetReturnValue(
    Dart_NativeArguments args,
    Object retval,
  ) {
    return _Dart_SetReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Handle)>>(
      'Dart_SetReturnValue');
  late final _Dart_SetReturnValue = _Dart_SetReturnValuePtr.asFunction<
      void Function(Dart_NativeArguments, Object)>();

  void Dart_SetWeakHandleReturnValue(
    Dart_NativeArguments args,
    Dart_WeakPersistentHandle rval,
  ) {
    return _Dart_SetWeakHandleReturnValue(
      args,
      rval,
    );
  }

  late final _Dart_SetWeakHandleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_NativeArguments,
              Dart_WeakPersistentHandle)>>('Dart_SetWeakHandleReturnValue');
  late final _Dart_SetWeakHandleReturnValue =
      _Dart_SetWeakHandleReturnValuePtr.asFunction<
          void Function(Dart_NativeArguments, Dart_WeakPersistentHandle)>();

  void Dart_SetBooleanReturnValue(
    Dart_NativeArguments args,
    bool retval,
  ) {
    return _Dart_SetBooleanReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetBooleanReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Bool)>>(
      'Dart_SetBooleanReturnValue');
  late final _Dart_SetBooleanReturnValue = _Dart_SetBooleanReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, bool)>();

  void Dart_SetIntegerReturnValue(
    Dart_NativeArguments args,
    int retval,
  ) {
    return _Dart_SetIntegerReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetIntegerReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Int64)>>(
      'Dart_SetIntegerReturnValue');
  late final _Dart_SetIntegerReturnValue = _Dart_SetIntegerReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, int)>();

  void Dart_SetDoubleReturnValue(
    Dart_NativeArguments args,
    double retval,
  ) {
    return _Dart_SetDoubleReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetDoubleReturnValuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Double)>>(
      'Dart_SetDoubleReturnValue');
  late final _Dart_SetDoubleReturnValue = _Dart_SetDoubleReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, double)>();

  /// Sets the environment callback for the current isolate. This
  /// callback is used to lookup environment values by name in the
  /// current environment. This enables the embedder to supply values for
  /// the const constructors bool.fromEnvironment, int.fromEnvironment
  /// and String.fromEnvironment.
  Object Dart_SetEnvironmentCallback(
    Dart_EnvironmentCallback callback,
  ) {
    return _Dart_SetEnvironmentCallback(
      callback,
    );
  }

  late final _Dart_SetEnvironmentCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_EnvironmentCallback)>>(
      'Dart_SetEnvironmentCallback');
  late final _Dart_SetEnvironmentCallback = _Dart_SetEnvironmentCallbackPtr
      .asFunction<Object Function(Dart_EnvironmentCallback)>();

  /// Sets the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver A native entry resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetNativeResolver(
    Object library1,
    Dart_NativeEntryResolver resolver,
    Dart_NativeEntrySymbol symbol,
  ) {
    return _Dart_SetNativeResolver(
      library1,
      resolver,
      symbol,
    );
  }

  late final _Dart_SetNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, Dart_NativeEntryResolver,
              Dart_NativeEntrySymbol)>>('Dart_SetNativeResolver');
  late final _Dart_SetNativeResolver = _Dart_SetNativeResolverPtr.asFunction<
      Object Function(
          Object, Dart_NativeEntryResolver, Dart_NativeEntrySymbol)>();

  /// Returns the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntryResolver
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeResolver(
    Object library1,
    ffi.Pointer<Dart_NativeEntryResolver> resolver,
  ) {
    return _Dart_GetNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeResolverPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntryResolver>)>>(
      'Dart_GetNativeResolver');
  late final _Dart_GetNativeResolver = _Dart_GetNativeResolverPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntryResolver>)>();

  /// Returns the callback used to resolve native function symbols for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntrySymbol.
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeSymbol(
    Object library1,
    ffi.Pointer<Dart_NativeEntrySymbol> resolver,
  ) {
    return _Dart_GetNativeSymbol(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeSymbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<Dart_NativeEntrySymbol>)>>('Dart_GetNativeSymbol');
  late final _Dart_GetNativeSymbol = _Dart_GetNativeSymbolPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntrySymbol>)>();

  /// Sets the callback used to resolve FFI native functions for a library.
  /// The resolved functions are expected to be a C function pointer of the
  /// correct signature (as specified in the `@Native<NFT>()` function
  /// annotation in Dart code).
  ///
  /// NOTE: This is an experimental feature and might change in the future.
  ///
  /// \param library A library.
  /// \param resolver A native function resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetFfiNativeResolver(
    Object library1,
    Dart_FfiNativeResolver resolver,
  ) {
    return _Dart_SetFfiNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_SetFfiNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              Dart_FfiNativeResolver)>>('Dart_SetFfiNativeResolver');
  late final _Dart_SetFfiNativeResolver = _Dart_SetFfiNativeResolverPtr
      .asFunction<Object Function(Object, Dart_FfiNativeResolver)>();

  /// Sets library tag handler for the current isolate. This handler is
  /// used to handle the various tags encountered while loading libraries
  /// or scripts in the isolate.
  ///
  /// \param handler Handler code to be used for handling the various tags
  /// encountered while loading libraries or scripts in the isolate.
  ///
  /// \return If no error occurs, the handler is set for the isolate.
  /// Otherwise an error handle is returned.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetLibraryTagHandler(
    Dart_LibraryTagHandler handler,
  ) {
    return _Dart_SetLibraryTagHandler(
      handler,
    );
  }

  late final _Dart_SetLibraryTagHandlerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_LibraryTagHandler)>>(
          'Dart_SetLibraryTagHandler');
  late final _Dart_SetLibraryTagHandler = _Dart_SetLibraryTagHandlerPtr
      .asFunction<Object Function(Dart_LibraryTagHandler)>();

  /// Sets the deferred load handler for the current isolate. This handler is
  /// used to handle loading deferred imports in an AppJIT or AppAOT program.
  Object Dart_SetDeferredLoadHandler(
    Dart_DeferredLoadHandler handler,
  ) {
    return _Dart_SetDeferredLoadHandler(
      handler,
    );
  }

  late final _Dart_SetDeferredLoadHandlerPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_DeferredLoadHandler)>>(
      'Dart_SetDeferredLoadHandler');
  late final _Dart_SetDeferredLoadHandler = _Dart_SetDeferredLoadHandlerPtr
      .asFunction<Object Function(Dart_DeferredLoadHandler)>();

  /// Notifies the VM that a deferred load completed successfully. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadComplete(
    int loading_unit_id,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
  ) {
    return _Dart_DeferredLoadComplete(
      loading_unit_id,
      snapshot_data,
      snapshot_instructions,
    );
  }

  late final _Dart_DeferredLoadCompletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>)>>('Dart_DeferredLoadComplete');
  late final _Dart_DeferredLoadComplete =
      _Dart_DeferredLoadCompletePtr.asFunction<
          Object Function(
              int, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>();

  /// Notifies the VM that a deferred load failed. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete with an error.
  ///
  /// If `transient` is true, future invocations of `prefix.loadLibrary()` will
  /// trigger new load requests. If false, futures invocation will complete with
  /// the same error.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadCompleteError(
    int loading_unit_id,
    ffi.Pointer<ffi.Char> error_message,
    bool transient,
  ) {
    return _Dart_DeferredLoadCompleteError(
      loading_unit_id,
      error_message,
      transient,
    );
  }

  late final _Dart_DeferredLoadCompleteErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('Dart_DeferredLoadCompleteError');
  late final _Dart_DeferredLoadCompleteError =
      _Dart_DeferredLoadCompleteErrorPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Canonicalizes a url with respect to some library.
  ///
  /// The url is resolved with respect to the library's url and some url
  /// normalizations are performed.
  ///
  /// This canonicalization function should be sufficient for most
  /// embedders to implement the Dart_kCanonicalizeUrl tag.
  ///
  /// \param base_url The base url relative to which the url is
  /// being resolved.
  /// \param url The url being resolved and canonicalized.  This
  /// parameter is a string handle.
  ///
  /// \return If no error occurs, a String object is returned.  Otherwise
  /// an error handle is returned.
  Object Dart_DefaultCanonicalizeUrl(
    Object base_url,
    Object url,
  ) {
    return _Dart_DefaultCanonicalizeUrl(
      base_url,
      url,
    );
  }

  late final _Dart_DefaultCanonicalizeUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_DefaultCanonicalizeUrl');
  late final _Dart_DefaultCanonicalizeUrl = _Dart_DefaultCanonicalizeUrlPtr
      .asFunction<Object Function(Object, Object)>();

  /// Loads the root library for the current isolate.
  ///
  /// Requires there to be no current root library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate group shutdown.
  /// \param kernel_size Length of the passed in buffer.
  ///
  /// \return A handle to the root library, or an error.
  Object Dart_LoadScriptFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_size,
  ) {
    return _Dart_LoadScriptFromKernel(
      kernel_buffer,
      kernel_size,
    );
  }

  late final _Dart_LoadScriptFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadScriptFromKernel');
  late final _Dart_LoadScriptFromKernel = _Dart_LoadScriptFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the library for the root script for the current isolate.
  ///
  /// If the root script has not yet been set for the current isolate,
  /// this function returns Dart_Null().  This function never returns an
  /// error handle.
  ///
  /// \return Returns the root Library for the current isolate or Dart_Null().
  Object Dart_RootLibrary() {
    return _Dart_RootLibrary();
  }

  late final _Dart_RootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RootLibrary');
  late final _Dart_RootLibrary =
      _Dart_RootLibraryPtr.asFunction<Object Function()>();

  /// Sets the root library for the current isolate.
  ///
  /// \return Returns an error handle if `library` is not a library handle.
  Object Dart_SetRootLibrary(
    Object library1,
  ) {
    return _Dart_SetRootLibrary(
      library1,
    );
  }

  late final _Dart_SetRootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_SetRootLibrary');
  late final _Dart_SetRootLibrary =
      _Dart_SetRootLibraryPtr.asFunction<Object Function(Object)>();

  /// Lookup or instantiate a legacy type by name and type arguments from a
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetType');
  late final _Dart_GetType = _Dart_GetTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNullableType');
  late final _Dart_GetNullableType = _Dart_GetNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a non-nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parametric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNonNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNonNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNonNullableType');
  late final _Dart_GetNonNullableType = _Dart_GetNonNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Creates a nullable version of the provided type.
  ///
  /// \param type The type to be converted to a nullable type.
  ///
  /// \return If no error occurs, a nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNullableType(
    Object type,
  ) {
    return _Dart_TypeToNullableType(
      type,
    );
  }

  late final _Dart_TypeToNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNullableType');
  late final _Dart_TypeToNullableType =
      _Dart_TypeToNullableTypePtr.asFunction<Object Function(Object)>();

  /// Creates a non-nullable version of the provided type.
  ///
  /// \param type The type to be converted to a non-nullable type.
  ///
  /// \return If no error occurs, a non-nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNonNullableType(
    Object type,
  ) {
    return _Dart_TypeToNonNullableType(
      type,
    );
  }

  late final _Dart_TypeToNonNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNonNullableType');
  late final _Dart_TypeToNonNullableType =
      _Dart_TypeToNonNullableTypePtr.asFunction<Object Function(Object)>();

  /// A type's nullability.
  ///
  /// \param type A Dart type.
  /// \param result An out parameter containing the result of the check. True if
  /// the type is of the specified nullability, false otherwise.
  ///
  /// \return Returns an error handle if type is not of type Type.
  Object Dart_IsNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNullableType');
  late final _Dart_IsNullableType = _Dart_IsNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsNonNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNonNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNonNullableType');
  late final _Dart_IsNonNullableType = _Dart_IsNonNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsLegacyType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsLegacyType(
      type,
      result,
    );
  }

  late final _Dart_IsLegacyTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsLegacyType');
  late final _Dart_IsLegacyType = _Dart_IsLegacyTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Lookup a class or interface by name from a Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The name of the class or interface.
  ///
  /// \return If no error occurs, the class or interface is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetClass(
    Object library1,
    Object class_name,
  ) {
    return _Dart_GetClass(
      library1,
      class_name,
    );
  }

  late final _Dart_GetClassPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetClass');
  late final _Dart_GetClass =
      _Dart_GetClassPtr.asFunction<Object Function(Object, Object)>();

  /// Returns an import path to a Library, such as "file:///test.dart" or
  /// "dart:core".
  Object Dart_LibraryUrl(
    Object library1,
  ) {
    return _Dart_LibraryUrl(
      library1,
    );
  }

  late final _Dart_LibraryUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryUrl');
  late final _Dart_LibraryUrl =
      _Dart_LibraryUrlPtr.asFunction<Object Function(Object)>();

  /// Returns a URL from which a Library was loaded.
  Object Dart_LibraryResolvedUrl(
    Object library1,
  ) {
    return _Dart_LibraryResolvedUrl(
      library1,
    );
  }

  late final _Dart_LibraryResolvedUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryResolvedUrl');
  late final _Dart_LibraryResolvedUrl =
      _Dart_LibraryResolvedUrlPtr.asFunction<Object Function(Object)>();

  /// \return An array of libraries.
  Object Dart_GetLoadedLibraries() {
    return _Dart_GetLoadedLibraries();
  }

  late final _Dart_GetLoadedLibrariesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_GetLoadedLibraries');
  late final _Dart_GetLoadedLibraries =
      _Dart_GetLoadedLibrariesPtr.asFunction<Object Function()>();

  Object Dart_LookupLibrary(
    Object url,
  ) {
    return _Dart_LookupLibrary(
      url,
    );
  }

  late final _Dart_LookupLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LookupLibrary');
  late final _Dart_LookupLibrary =
      _Dart_LookupLibraryPtr.asFunction<Object Function(Object)>();

  /// Report an loading error for the library.
  ///
  /// \param library The library that failed to load.
  /// \param error The Dart error instance containing the load error.
  ///
  /// \return If the VM handles the error, the return value is
  /// a null handle. If it doesn't handle the error, the error
  /// object is returned.
  Object Dart_LibraryHandleError(
    Object library1,
    Object error,
  ) {
    return _Dart_LibraryHandleError(
      library1,
      error,
    );
  }

  late final _Dart_LibraryHandleErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_LibraryHandleError');
  late final _Dart_LibraryHandleError =
      _Dart_LibraryHandleErrorPtr.asFunction<Object Function(Object, Object)>();

  /// Called by the embedder to load a partial program. Does not set the root
  /// library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate shutdown.
  /// \param kernel_buffer_size Length of the passed in buffer.
  ///
  /// \return A handle to the main library of the compilation unit, or an error.
  Object Dart_LoadLibraryFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_LoadLibraryFromKernel(
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_LoadLibraryFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadLibraryFromKernel');
  late final _Dart_LoadLibraryFromKernel = _Dart_LoadLibraryFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  Object Dart_LoadLibrary(
    Object kernel_buffer,
  ) {
    return _Dart_LoadLibrary(
      kernel_buffer,
    );
  }

  late final _Dart_LoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LoadLibrary');
  late final _Dart_LoadLibrary =
      _Dart_LoadLibraryPtr.asFunction<Object Function(Object)>();

  /// Indicates that all outstanding load requests have been satisfied.
  /// This finalizes all the new classes loaded and optionally completes
  /// deferred library futures.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param complete_futures Specify true if all deferred library
  /// futures should be completed, false otherwise.
  ///
  /// \return Success if all classes have been finalized and deferred library
  /// futures are completed. Otherwise, returns an error.
  Object Dart_FinalizeLoading(
    bool complete_futures,
  ) {
    return _Dart_FinalizeLoading(
      complete_futures,
    );
  }

  late final _Dart_FinalizeLoadingPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_FinalizeLoading');
  late final _Dart_FinalizeLoading =
      _Dart_FinalizeLoadingPtr.asFunction<Object Function(bool)>();

  /// Returns the value of peer field of 'object' in 'peer'.
  ///
  /// \param object An object.
  /// \param peer An out parameter that returns the value of the peer
  /// field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_GetPeer(
    Object object,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetPeer(
      object,
      peer,
    );
  }

  late final _Dart_GetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_GetPeer');
  late final _Dart_GetPeer = _Dart_GetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Sets the value of the peer field of 'object' to the value of
  /// 'peer'.
  ///
  /// \param object An object.
  /// \param peer A value to store in the peer field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_SetPeer(
    Object object,
    ffi.Pointer<ffi.Void> peer,
  ) {
    return _Dart_SetPeer(
      object,
      peer,
    );
  }

  late final _Dart_SetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Void>)>>('Dart_SetPeer');
  late final _Dart_SetPeer = _Dart_SetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Void>)>();

  bool Dart_IsKernelIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsKernelIsolate(
      isolate,
    );
  }

  late final _Dart_IsKernelIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsKernelIsolate');
  late final _Dart_IsKernelIsolate =
      _Dart_IsKernelIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  bool Dart_KernelIsolateIsRunning() {
    return _Dart_KernelIsolateIsRunning();
  }

  late final _Dart_KernelIsolateIsRunningPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_KernelIsolateIsRunning');
  late final _Dart_KernelIsolateIsRunning =
      _Dart_KernelIsolateIsRunningPtr.asFunction<bool Function()>();

  int Dart_KernelPort() {
    return _Dart_KernelPort();
  }

  late final _Dart_KernelPortPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_KernelPort');
  late final _Dart_KernelPort =
      _Dart_KernelPortPtr.asFunction<int Function()>();

  /// Compiles the given `script_uri` to a kernel file.
  ///
  /// \param platform_kernel A buffer containing the kernel of the platform (e.g.
  /// `vm_platform_strong.dill`). The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  ///
  /// \param snapshot_compile Set to `true` when the compilation is for a snapshot.
  /// This is used by the frontend to determine if compilation related information
  /// should be printed to console (e.g., null safety mode).
  ///
  /// \param embed_sources Set to `true` when sources should be embedded in the
  /// kernel file.
  ///
  /// \param verbosity Specifies the logging behavior of the kernel compilation
  /// service.
  ///
  /// \return Returns the result of the compilation.
  ///
  /// On a successful compilation the returned [Dart_KernelCompilationResult] has
  /// a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`
  /// fields are set. The caller takes ownership of the malloc()ed buffer.
  ///
  /// On a failed compilation the `error` might be set describing the reason for
  /// the failed compilation. The caller takes ownership of the malloc()ed
  /// error.
  ///
  /// Requires there to be a current isolate.
  Dart_KernelCompilationResult Dart_CompileToKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
    bool incremental_compile,
    bool snapshot_compile,
    bool embed_sources,
    ffi.Pointer<ffi.Char> package_config,
    int verbosity,
  ) {
    return _Dart_CompileToKernel(
      script_uri,
      platform_kernel,
      platform_kernel_size,
      incremental_compile,
      snapshot_compile,
      embed_sources,
      package_config,
      verbosity,
    );
  }

  late final _Dart_CompileToKernelPtr = _lookup<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('Dart_CompileToKernel');
  late final _Dart_CompileToKernel = _Dart_CompileToKernelPtr.asFunction<
      Dart_KernelCompilationResult Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          int,
          bool,
          bool,
          bool,
          ffi.Pointer<ffi.Char>,
          int)>();

  Dart_KernelCompilationResult Dart_KernelListDependencies() {
    return _Dart_KernelListDependencies();
  }

  late final _Dart_KernelListDependenciesPtr =
      _lookup<ffi.NativeFunction<Dart_KernelCompilationResult Function()>>(
          'Dart_KernelListDependencies');
  late final _Dart_KernelListDependencies = _Dart_KernelListDependenciesPtr
      .asFunction<Dart_KernelCompilationResult Function()>();

  /// Sets the kernel buffer which will be used to load Dart SDK sources
  /// dynamically at runtime.
  ///
  /// \param platform_kernel A buffer containing kernel which has sources for the
  /// Dart SDK populated. Note: The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  void Dart_SetDartLibrarySourcesKernel(
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
  ) {
    return _Dart_SetDartLibrarySourcesKernel(
      platform_kernel,
      platform_kernel_size,
    );
  }

  late final _Dart_SetDartLibrarySourcesKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_SetDartLibrarySourcesKernel');
  late final _Dart_SetDartLibrarySourcesKernel =
      _Dart_SetDartLibrarySourcesKernelPtr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Detect the null safety opt-in status.
  ///
  /// When running from source, it is based on the opt-in status of `script_uri`.
  /// When running from a kernel buffer, it is based on the mode used when
  /// generating `kernel_buffer`.
  /// When running from an appJIT or AOT snapshot, it is based on the mode used
  /// when generating `snapshot_data`.
  ///
  /// \param script_uri Uri of the script that contains the source code
  ///
  /// \param package_config Uri of the package configuration file (either in format
  /// of .packages or .dart_tool/package_config.json) for the null safety
  /// detection to resolve package imports against. If this parameter is not
  /// passed the package resolution of the parent isolate should be used.
  ///
  /// \param original_working_directory current working directory when the VM
  /// process was launched, this is used to correctly resolve the path specified
  /// for package_config.
  ///
  /// \param snapshot_data Buffer containing the snapshot data of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffers must
  /// remain valid until the isolate shuts down.
  ///
  /// \param snapshot_instructions Buffer containing the snapshot instructions of
  /// the isolate or NULL if no snapshot is provided. If provided, the buffers
  /// must remain valid until the isolate shuts down.
  ///
  /// \param kernel_buffer A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  ///
  /// \param kernel_buffer_size The size of `kernel_buffer`.
  ///
  /// \return Returns true if the null safety is opted in by the input being
  /// run `script_uri`, `snapshot_data` or `kernel_buffer`.
  bool Dart_DetectNullSafety(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> package_config,
    ffi.Pointer<ffi.Char> original_working_directory,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_DetectNullSafety(
      script_uri,
      package_config,
      original_working_directory,
      snapshot_data,
      snapshot_instructions,
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_DetectNullSafetyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_DetectNullSafety');
  late final _Dart_DetectNullSafety = _Dart_DetectNullSafetyPtr.asFunction<
      bool Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// Returns true if isolate is the service isolate.
  ///
  /// \param isolate An isolate
  ///
  /// \return Returns true if 'isolate' is the service isolate.
  bool Dart_IsServiceIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsServiceIsolate(
      isolate,
    );
  }

  late final _Dart_IsServiceIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsServiceIsolate');
  late final _Dart_IsServiceIsolate =
      _Dart_IsServiceIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  /// Writes the CPU profile to the timeline as a series of 'instant' events.
  ///
  /// Note that this is an expensive operation.
  ///
  /// \param main_port The main port of the Isolate whose profile samples to write.
  /// \param error An optional error, must be free()ed by caller.
  ///
  /// \return Returns true if the profile is successfully written and false
  /// otherwise.
  bool Dart_WriteProfileToTimeline(
    int main_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_WriteProfileToTimeline(
      main_port,
      error,
    );
  }

  late final _Dart_WriteProfileToTimelinePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  Dart_Port, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_WriteProfileToTimeline');
  late final _Dart_WriteProfileToTimeline = _Dart_WriteProfileToTimelinePtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Compiles all functions reachable from entry points and marks
  /// the isolate to disallow future compilation.
  ///
  /// Entry points should be specified using `@pragma("vm:entry-point")`
  /// annotation.
  ///
  /// \return An error handle if a compilation error or runtime error running const
  /// constructors was encountered.
  Object Dart_Precompile() {
    return _Dart_Precompile();
  }

  late final _Dart_PrecompilePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Precompile');
  late final _Dart_Precompile =
      _Dart_PrecompilePtr.asFunction<Object Function()>();

  Object Dart_LoadingUnitLibraryUris(
    int loading_unit_id,
  ) {
    return _Dart_LoadingUnitLibraryUris(
      loading_unit_id,
    );
  }

  late final _Dart_LoadingUnitLibraryUrisPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_LoadingUnitLibraryUris');
  late final _Dart_LoadingUnitLibraryUris =
      _Dart_LoadingUnitLibraryUrisPtr.asFunction<Object Function(int)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an assembly file defining the symbols listed in the definitions
  /// above.
  ///
  /// The assembly should be compiled as a static or shared library and linked or
  /// loaded by the embedder. Running this snapshot requires a VM compiled with
  /// DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and
  /// kDartVmSnapshotInstructions should be passed to Dart_Initialize. The
  /// kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be
  /// passed to Dart_CreateIsolateGroup.
  ///
  /// The callback will be invoked one or more times to provide the assembly code.
  ///
  /// If stripped is true, then the assembly code will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssembly(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsAssembly');
  late final _Dart_CreateAppAOTSnapshotAsAssembly =
      _Dart_CreateAppAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsAssemblies(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssemblies(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssembliesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>(
      'Dart_CreateAppAOTSnapshotAsAssemblies');
  late final _Dart_CreateAppAOTSnapshotAsAssemblies =
      _Dart_CreateAppAOTSnapshotAsAssembliesPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an ELF shared library defining the symbols
  /// - _kDartVmSnapshotData
  /// - _kDartVmSnapshotInstructions
  /// - _kDartIsolateSnapshotData
  /// - _kDartIsolateSnapshotInstructions
  ///
  /// The shared library should be dynamically loaded by the embedder.
  /// Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.
  /// The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to
  /// Dart_Initialize. The kDartIsolateSnapshotData and
  /// kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.
  ///
  /// The callback will be invoked one or more times to provide the binary output.
  ///
  /// If stripped is true, then the binary output will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsElf(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElf(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsElf');
  late final _Dart_CreateAppAOTSnapshotAsElf =
      _Dart_CreateAppAOTSnapshotAsElfPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsElfs(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElfs(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>>('Dart_CreateAppAOTSnapshotAsElfs');
  late final _Dart_CreateAppAOTSnapshotAsElfs =
      _Dart_CreateAppAOTSnapshotAsElfsPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes
  /// kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does
  /// not strip DWARF information from the generated assembly or allow for
  /// separate debug information.
  Object Dart_CreateVMAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _Dart_CreateVMAOTSnapshotAsAssembly(
      callback,
      callback_data,
    );
  }

  late final _Dart_CreateVMAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateVMAOTSnapshotAsAssembly');
  late final _Dart_CreateVMAOTSnapshotAsAssembly =
      _Dart_CreateVMAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(
              Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>)>();

  /// Sorts the class-ids in depth first traversal order of the inheritance
  /// tree. This is a costly operation, but it can make method dispatch
  /// more efficient and is done before writing snapshots.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_SortClasses() {
    return _Dart_SortClasses();
  }

  late final _Dart_SortClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_SortClasses');
  late final _Dart_SortClasses =
      _Dart_SortClassesPtr.asFunction<Object Function()>();

  /// Creates a snapshot that caches compiled code and type feedback for faster
  /// startup and quicker warmup in a subsequent process.
  ///
  /// Outputs a snapshot in two pieces. The pieces should be passed to
  /// Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the
  /// current VM. The instructions piece must be loaded with read and execute
  /// permissions; the data piece may be loaded as read-only.
  ///
  /// - Requires the VM to have not been started with --precompilation.
  /// - Not supported when targeting IA32.
  /// - The VM writing the snapshot and the VM reading the snapshot must be the
  /// same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must
  /// be targeting the same architecture, and must both be in checked mode or
  /// both in unchecked mode.
  ///
  /// The buffers are scope allocated and are only valid until the next call to
  /// Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateAppJITSnapshotAsBlobs(
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateAppJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateAppJITSnapshotAsBlobs');
  late final _Dart_CreateAppJITSnapshotAsBlobs =
      _Dart_CreateAppJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Like Dart_CreateAppJITSnapshotAsBlobs, but also creates a new VM snapshot.
  Object Dart_CreateCoreJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_instructions_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateCoreJITSnapshotAsBlobs(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      vm_snapshot_instructions_buffer,
      vm_snapshot_instructions_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateCoreJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateCoreJITSnapshotAsBlobs');
  late final _Dart_CreateCoreJITSnapshotAsBlobs =
      _Dart_CreateCoreJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Get obfuscation map for precompiled code.
  ///
  /// Obfuscation map is encoded as a JSON array of pairs (original name,
  /// obfuscated name).
  ///
  /// \return Returns an error handler if the VM was built in a mode that does not
  /// support obfuscation.
  Object Dart_GetObfuscationMap(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.IntPtr> buffer_length,
  ) {
    return _Dart_GetObfuscationMap(
      buffer,
      buffer_length,
    );
  }

  late final _Dart_GetObfuscationMapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetObfuscationMap');
  late final _Dart_GetObfuscationMap = _Dart_GetObfuscationMapPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns whether the VM only supports running from precompiled snapshots and
  /// not from any other kind of snapshot or from source (that is, the VM was
  /// compiled with DART_PRECOMPILED_RUNTIME).
  bool Dart_IsPrecompiledRuntime() {
    return _Dart_IsPrecompiledRuntime();
  }

  late final _Dart_IsPrecompiledRuntimePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_IsPrecompiledRuntime');
  late final _Dart_IsPrecompiledRuntime =
      _Dart_IsPrecompiledRuntimePtr.asFunction<bool Function()>();

  /// Print a native stack trace. Used for crash handling.
  ///
  /// If context is NULL, prints the current stack trace. Otherwise, context
  /// should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler
  /// running on the current thread.
  void Dart_DumpNativeStackTrace(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _Dart_DumpNativeStackTrace(
      context,
    );
  }

  late final _Dart_DumpNativeStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_DumpNativeStackTrace');
  late final _Dart_DumpNativeStackTrace = _Dart_DumpNativeStackTracePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Indicate that the process is about to abort, and the Dart VM should not
  /// attempt to cleanup resources.
  void Dart_PrepareToAbort() {
    return _Dart_PrepareToAbort();
  }

  late final _Dart_PrepareToAbortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_PrepareToAbort');
  late final _Dart_PrepareToAbort =
      _Dart_PrepareToAbortPtr.asFunction<void Function()>();

  /// Configure DWARF stack trace footnote callback.
  void Dart_SetDwarfStackTraceFootnoteCallback(
    Dart_DwarfStackTraceFootnoteCallback callback,
  ) {
    return _Dart_SetDwarfStackTraceFootnoteCallback(
      callback,
    );
  }

  late final _Dart_SetDwarfStackTraceFootnoteCallbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Dart_DwarfStackTraceFootnoteCallback)>>(
      'Dart_SetDwarfStackTraceFootnoteCallback');
  late final _Dart_SetDwarfStackTraceFootnoteCallback =
      _Dart_SetDwarfStackTraceFootnoteCallbackPtr.asFunction<
          void Function(Dart_DwarfStackTraceFootnoteCallback)>();

  /// Posts a message on some port. The message will contain the Dart_CObject
  /// object graph rooted in 'message'.
  ///
  /// While the message is being sent the state of the graph of Dart_CObject
  /// structures rooted in 'message' should not be accessed, as the message
  /// generation will make temporary modifications to the data. When the message
  /// has been sent the graph will be fully restored.
  ///
  /// If true is returned, the message was enqueued, and finalizers for external
  /// typed data will eventually run, even if the receiving isolate shuts down
  /// before processing the message. If false is returned, the message was not
  /// enqueued and ownership of external typed data in the message remains with the
  /// caller.
  ///
  /// This function may be called on any thread when the VM is running (that is,
  /// after Dart_Initialize has returned and before Dart_Cleanup has been called).
  ///
  /// \param port_id The destination port.
  /// \param message The message to send.
  ///
  /// \return True if the message was posted.
  bool Dart_PostCObject(
    int port_id,
    ffi.Pointer<Dart_CObject> message,
  ) {
    return _Dart_PostCObject(
      port_id,
      message,
    );
  }

  late final _Dart_PostCObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Dart_Port, ffi.Pointer<Dart_CObject>)>>('Dart_PostCObject');
  late final _Dart_PostCObject = _Dart_PostCObjectPtr.asFunction<
      bool Function(int, ffi.Pointer<Dart_CObject>)>();

  /// Posts a message on some port. The message will contain the integer 'message'.
  ///
  /// \param port_id The destination port.
  /// \param message The message to send.
  ///
  /// \return True if the message was posted.
  bool Dart_PostInteger(
    int port_id,
    int message,
  ) {
    return _Dart_PostInteger(
      port_id,
      message,
    );
  }

  late final _Dart_PostIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Int64)>>(
          'Dart_PostInteger');
  late final _Dart_PostInteger =
      _Dart_PostIntegerPtr.asFunction<bool Function(int, int)>();

  /// Creates a new native port.  When messages are received on this
  /// native port, then they will be dispatched to the provided native
  /// message handler.
  ///
  /// \param name The name of this port in debugging messages.
  /// \param handler The C handler to run when messages arrive on the port.
  /// \param handle_concurrently Is it okay to process requests on this
  /// native port concurrently?
  ///
  /// \return If successful, returns the port id for the native port.  In
  /// case of error, returns ILLEGAL_PORT.
  int Dart_NewNativePort(
    ffi.Pointer<ffi.Char> name,
    Dart_NativeMessageHandler handler,
    bool handle_concurrently,
  ) {
    return _Dart_NewNativePort(
      name,
      handler,
      handle_concurrently,
    );
  }

  late final _Dart_NewNativePortPtr = _lookup<
      ffi.NativeFunction<
          Dart_Port Function(ffi.Pointer<ffi.Char>, Dart_NativeMessageHandler,
              ffi.Bool)>>('Dart_NewNativePort');
  late final _Dart_NewNativePort = _Dart_NewNativePortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, Dart_NativeMessageHandler, bool)>();

  /// Closes the native port with the given id.
  ///
  /// The port must have been allocated by a call to Dart_NewNativePort.
  ///
  /// \param native_port_id The id of the native port to close.
  ///
  /// \return Returns true if the port was closed successfully.
  bool Dart_CloseNativePort(
    int native_port_id,
  ) {
    return _Dart_CloseNativePort(
      native_port_id,
    );
  }

  late final _Dart_CloseNativePortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port)>>(
          'Dart_CloseNativePort');
  late final _Dart_CloseNativePort =
      _Dart_CloseNativePortPtr.asFunction<bool Function(int)>();

  /// Forces all loaded classes and functions to be compiled eagerly in
  /// the current isolate..
  ///
  /// TODO(turnidge): Document.
  Object Dart_CompileAll() {
    return _Dart_CompileAll();
  }

  late final _Dart_CompileAllPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_CompileAll');
  late final _Dart_CompileAll =
      _Dart_CompileAllPtr.asFunction<Object Function()>();

  /// Finalizes all classes.
  Object Dart_FinalizeAllClasses() {
    return _Dart_FinalizeAllClasses();
  }

  late final _Dart_FinalizeAllClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_FinalizeAllClasses');
  late final _Dart_FinalizeAllClasses =
      _Dart_FinalizeAllClassesPtr.asFunction<Object Function()>();

  ffi.Pointer<ffi.Void> Dart_ExecuteInternalCommand(
    ffi.Pointer<ffi.Char> command,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _Dart_ExecuteInternalCommand(
      command,
      arg,
    );
  }

  late final _Dart_ExecuteInternalCommandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('Dart_ExecuteInternalCommand');
  late final _Dart_ExecuteInternalCommand =
      _Dart_ExecuteInternalCommandPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// \mainpage Dynamically Linked Dart API
  ///
  /// This exposes a subset of symbols from dart_api.h and dart_native_api.h
  /// available in every Dart embedder through dynamic linking.
  ///
  /// All symbols are postfixed with _DL to indicate that they are dynamically
  /// linked and to prevent conflicts with the original symbol.
  ///
  /// Link `dart_api_dl.c` file into your library and invoke
  /// `Dart_InitializeApiDL` with `NativeApi.initializeApiDLData`.
  int Dart_InitializeApiDL(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _Dart_InitializeApiDL(
      data,
    );
  }

  late final _Dart_InitializeApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_InitializeApiDL');
  late final _Dart_InitializeApiDL = _Dart_InitializeApiDLPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>)>();

  late final ffi.Pointer<Dart_PostCObject_Type> _Dart_PostCObject_DL =
      _lookup<Dart_PostCObject_Type>('Dart_PostCObject_DL');

  Dart_PostCObject_Type get Dart_PostCObject_DL => _Dart_PostCObject_DL.value;

  set Dart_PostCObject_DL(Dart_PostCObject_Type value) =>
      _Dart_PostCObject_DL.value = value;

  late final ffi.Pointer<Dart_PostInteger_Type> _Dart_PostInteger_DL =
      _lookup<Dart_PostInteger_Type>('Dart_PostInteger_DL');

  Dart_PostInteger_Type get Dart_PostInteger_DL => _Dart_PostInteger_DL.value;

  set Dart_PostInteger_DL(Dart_PostInteger_Type value) =>
      _Dart_PostInteger_DL.value = value;

  late final ffi.Pointer<Dart_NewNativePort_Type> _Dart_NewNativePort_DL =
      _lookup<Dart_NewNativePort_Type>('Dart_NewNativePort_DL');

  Dart_NewNativePort_Type get Dart_NewNativePort_DL =>
      _Dart_NewNativePort_DL.value;

  set Dart_NewNativePort_DL(Dart_NewNativePort_Type value) =>
      _Dart_NewNativePort_DL.value = value;

  late final ffi.Pointer<Dart_CloseNativePort_Type> _Dart_CloseNativePort_DL =
      _lookup<Dart_CloseNativePort_Type>('Dart_CloseNativePort_DL');

  Dart_CloseNativePort_Type get Dart_CloseNativePort_DL =>
      _Dart_CloseNativePort_DL.value;

  set Dart_CloseNativePort_DL(Dart_CloseNativePort_Type value) =>
      _Dart_CloseNativePort_DL.value = value;

  late final ffi.Pointer<Dart_IsError_Type> _Dart_IsError_DL =
      _lookup<Dart_IsError_Type>('Dart_IsError_DL');

  Dart_IsError_Type get Dart_IsError_DL => _Dart_IsError_DL.value;

  set Dart_IsError_DL(Dart_IsError_Type value) =>
      _Dart_IsError_DL.value = value;

  late final ffi.Pointer<Dart_IsApiError_Type> _Dart_IsApiError_DL =
      _lookup<Dart_IsApiError_Type>('Dart_IsApiError_DL');

  Dart_IsApiError_Type get Dart_IsApiError_DL => _Dart_IsApiError_DL.value;

  set Dart_IsApiError_DL(Dart_IsApiError_Type value) =>
      _Dart_IsApiError_DL.value = value;

  late final ffi.Pointer<Dart_IsUnhandledExceptionError_Type>
      _Dart_IsUnhandledExceptionError_DL =
      _lookup<Dart_IsUnhandledExceptionError_Type>(
          'Dart_IsUnhandledExceptionError_DL');

  Dart_IsUnhandledExceptionError_Type get Dart_IsUnhandledExceptionError_DL =>
      _Dart_IsUnhandledExceptionError_DL.value;

  set Dart_IsUnhandledExceptionError_DL(
          Dart_IsUnhandledExceptionError_Type value) =>
      _Dart_IsUnhandledExceptionError_DL.value = value;

  late final ffi.Pointer<Dart_IsCompilationError_Type>
      _Dart_IsCompilationError_DL =
      _lookup<Dart_IsCompilationError_Type>('Dart_IsCompilationError_DL');

  Dart_IsCompilationError_Type get Dart_IsCompilationError_DL =>
      _Dart_IsCompilationError_DL.value;

  set Dart_IsCompilationError_DL(Dart_IsCompilationError_Type value) =>
      _Dart_IsCompilationError_DL.value = value;

  late final ffi.Pointer<Dart_IsFatalError_Type> _Dart_IsFatalError_DL =
      _lookup<Dart_IsFatalError_Type>('Dart_IsFatalError_DL');

  Dart_IsFatalError_Type get Dart_IsFatalError_DL =>
      _Dart_IsFatalError_DL.value;

  set Dart_IsFatalError_DL(Dart_IsFatalError_Type value) =>
      _Dart_IsFatalError_DL.value = value;

  late final ffi.Pointer<Dart_GetError_Type> _Dart_GetError_DL =
      _lookup<Dart_GetError_Type>('Dart_GetError_DL');

  Dart_GetError_Type get Dart_GetError_DL => _Dart_GetError_DL.value;

  set Dart_GetError_DL(Dart_GetError_Type value) =>
      _Dart_GetError_DL.value = value;

  late final ffi.Pointer<Dart_ErrorHasException_Type>
      _Dart_ErrorHasException_DL =
      _lookup<Dart_ErrorHasException_Type>('Dart_ErrorHasException_DL');

  Dart_ErrorHasException_Type get Dart_ErrorHasException_DL =>
      _Dart_ErrorHasException_DL.value;

  set Dart_ErrorHasException_DL(Dart_ErrorHasException_Type value) =>
      _Dart_ErrorHasException_DL.value = value;

  late final ffi.Pointer<Dart_ErrorGetException_Type>
      _Dart_ErrorGetException_DL =
      _lookup<Dart_ErrorGetException_Type>('Dart_ErrorGetException_DL');

  Dart_ErrorGetException_Type get Dart_ErrorGetException_DL =>
      _Dart_ErrorGetException_DL.value;

  set Dart_ErrorGetException_DL(Dart_ErrorGetException_Type value) =>
      _Dart_ErrorGetException_DL.value = value;

  late final ffi.Pointer<Dart_ErrorGetStackTrace_Type>
      _Dart_ErrorGetStackTrace_DL =
      _lookup<Dart_ErrorGetStackTrace_Type>('Dart_ErrorGetStackTrace_DL');

  Dart_ErrorGetStackTrace_Type get Dart_ErrorGetStackTrace_DL =>
      _Dart_ErrorGetStackTrace_DL.value;

  set Dart_ErrorGetStackTrace_DL(Dart_ErrorGetStackTrace_Type value) =>
      _Dart_ErrorGetStackTrace_DL.value = value;

  late final ffi.Pointer<Dart_NewApiError_Type> _Dart_NewApiError_DL =
      _lookup<Dart_NewApiError_Type>('Dart_NewApiError_DL');

  Dart_NewApiError_Type get Dart_NewApiError_DL => _Dart_NewApiError_DL.value;

  set Dart_NewApiError_DL(Dart_NewApiError_Type value) =>
      _Dart_NewApiError_DL.value = value;

  late final ffi.Pointer<Dart_NewCompilationError_Type>
      _Dart_NewCompilationError_DL =
      _lookup<Dart_NewCompilationError_Type>('Dart_NewCompilationError_DL');

  Dart_NewCompilationError_Type get Dart_NewCompilationError_DL =>
      _Dart_NewCompilationError_DL.value;

  set Dart_NewCompilationError_DL(Dart_NewCompilationError_Type value) =>
      _Dart_NewCompilationError_DL.value = value;

  late final ffi.Pointer<Dart_NewUnhandledExceptionError_Type>
      _Dart_NewUnhandledExceptionError_DL =
      _lookup<Dart_NewUnhandledExceptionError_Type>(
          'Dart_NewUnhandledExceptionError_DL');

  Dart_NewUnhandledExceptionError_Type get Dart_NewUnhandledExceptionError_DL =>
      _Dart_NewUnhandledExceptionError_DL.value;

  set Dart_NewUnhandledExceptionError_DL(
          Dart_NewUnhandledExceptionError_Type value) =>
      _Dart_NewUnhandledExceptionError_DL.value = value;

  late final ffi.Pointer<Dart_PropagateError_Type> _Dart_PropagateError_DL =
      _lookup<Dart_PropagateError_Type>('Dart_PropagateError_DL');

  Dart_PropagateError_Type get Dart_PropagateError_DL =>
      _Dart_PropagateError_DL.value;

  set Dart_PropagateError_DL(Dart_PropagateError_Type value) =>
      _Dart_PropagateError_DL.value = value;

  late final ffi.Pointer<Dart_HandleFromPersistent_Type>
      _Dart_HandleFromPersistent_DL =
      _lookup<Dart_HandleFromPersistent_Type>('Dart_HandleFromPersistent_DL');

  Dart_HandleFromPersistent_Type get Dart_HandleFromPersistent_DL =>
      _Dart_HandleFromPersistent_DL.value;

  set Dart_HandleFromPersistent_DL(Dart_HandleFromPersistent_Type value) =>
      _Dart_HandleFromPersistent_DL.value = value;

  late final ffi.Pointer<Dart_HandleFromWeakPersistent_Type>
      _Dart_HandleFromWeakPersistent_DL =
      _lookup<Dart_HandleFromWeakPersistent_Type>(
          'Dart_HandleFromWeakPersistent_DL');

  Dart_HandleFromWeakPersistent_Type get Dart_HandleFromWeakPersistent_DL =>
      _Dart_HandleFromWeakPersistent_DL.value;

  set Dart_HandleFromWeakPersistent_DL(
          Dart_HandleFromWeakPersistent_Type value) =>
      _Dart_HandleFromWeakPersistent_DL.value = value;

  late final ffi.Pointer<Dart_NewPersistentHandle_Type>
      _Dart_NewPersistentHandle_DL =
      _lookup<Dart_NewPersistentHandle_Type>('Dart_NewPersistentHandle_DL');

  Dart_NewPersistentHandle_Type get Dart_NewPersistentHandle_DL =>
      _Dart_NewPersistentHandle_DL.value;

  set Dart_NewPersistentHandle_DL(Dart_NewPersistentHandle_Type value) =>
      _Dart_NewPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_SetPersistentHandle_Type>
      _Dart_SetPersistentHandle_DL =
      _lookup<Dart_SetPersistentHandle_Type>('Dart_SetPersistentHandle_DL');

  Dart_SetPersistentHandle_Type get Dart_SetPersistentHandle_DL =>
      _Dart_SetPersistentHandle_DL.value;

  set Dart_SetPersistentHandle_DL(Dart_SetPersistentHandle_Type value) =>
      _Dart_SetPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeletePersistentHandle_Type>
      _Dart_DeletePersistentHandle_DL =
      _lookup<Dart_DeletePersistentHandle_Type>(
          'Dart_DeletePersistentHandle_DL');

  Dart_DeletePersistentHandle_Type get Dart_DeletePersistentHandle_DL =>
      _Dart_DeletePersistentHandle_DL.value;

  set Dart_DeletePersistentHandle_DL(Dart_DeletePersistentHandle_Type value) =>
      _Dart_DeletePersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_NewWeakPersistentHandle_Type>
      _Dart_NewWeakPersistentHandle_DL =
      _lookup<Dart_NewWeakPersistentHandle_Type>(
          'Dart_NewWeakPersistentHandle_DL');

  Dart_NewWeakPersistentHandle_Type get Dart_NewWeakPersistentHandle_DL =>
      _Dart_NewWeakPersistentHandle_DL.value;

  set Dart_NewWeakPersistentHandle_DL(
          Dart_NewWeakPersistentHandle_Type value) =>
      _Dart_NewWeakPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeleteWeakPersistentHandle_Type>
      _Dart_DeleteWeakPersistentHandle_DL =
      _lookup<Dart_DeleteWeakPersistentHandle_Type>(
          'Dart_DeleteWeakPersistentHandle_DL');

  Dart_DeleteWeakPersistentHandle_Type get Dart_DeleteWeakPersistentHandle_DL =>
      _Dart_DeleteWeakPersistentHandle_DL.value;

  set Dart_DeleteWeakPersistentHandle_DL(
          Dart_DeleteWeakPersistentHandle_Type value) =>
      _Dart_DeleteWeakPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_NewFinalizableHandle_Type>
      _Dart_NewFinalizableHandle_DL =
      _lookup<Dart_NewFinalizableHandle_Type>('Dart_NewFinalizableHandle_DL');

  Dart_NewFinalizableHandle_Type get Dart_NewFinalizableHandle_DL =>
      _Dart_NewFinalizableHandle_DL.value;

  set Dart_NewFinalizableHandle_DL(Dart_NewFinalizableHandle_Type value) =>
      _Dart_NewFinalizableHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeleteFinalizableHandle_Type>
      _Dart_DeleteFinalizableHandle_DL =
      _lookup<Dart_DeleteFinalizableHandle_Type>(
          'Dart_DeleteFinalizableHandle_DL');

  Dart_DeleteFinalizableHandle_Type get Dart_DeleteFinalizableHandle_DL =>
      _Dart_DeleteFinalizableHandle_DL.value;

  set Dart_DeleteFinalizableHandle_DL(
          Dart_DeleteFinalizableHandle_Type value) =>
      _Dart_DeleteFinalizableHandle_DL.value = value;

  late final ffi.Pointer<Dart_CurrentIsolate_Type> _Dart_CurrentIsolate_DL =
      _lookup<Dart_CurrentIsolate_Type>('Dart_CurrentIsolate_DL');

  Dart_CurrentIsolate_Type get Dart_CurrentIsolate_DL =>
      _Dart_CurrentIsolate_DL.value;

  set Dart_CurrentIsolate_DL(Dart_CurrentIsolate_Type value) =>
      _Dart_CurrentIsolate_DL.value = value;

  late final ffi.Pointer<Dart_ExitIsolate_Type> _Dart_ExitIsolate_DL =
      _lookup<Dart_ExitIsolate_Type>('Dart_ExitIsolate_DL');

  Dart_ExitIsolate_Type get Dart_ExitIsolate_DL => _Dart_ExitIsolate_DL.value;

  set Dart_ExitIsolate_DL(Dart_ExitIsolate_Type value) =>
      _Dart_ExitIsolate_DL.value = value;

  late final ffi.Pointer<Dart_EnterIsolate_Type> _Dart_EnterIsolate_DL =
      _lookup<Dart_EnterIsolate_Type>('Dart_EnterIsolate_DL');

  Dart_EnterIsolate_Type get Dart_EnterIsolate_DL =>
      _Dart_EnterIsolate_DL.value;

  set Dart_EnterIsolate_DL(Dart_EnterIsolate_Type value) =>
      _Dart_EnterIsolate_DL.value = value;

  late final ffi.Pointer<Dart_Post_Type> _Dart_Post_DL =
      _lookup<Dart_Post_Type>('Dart_Post_DL');

  Dart_Post_Type get Dart_Post_DL => _Dart_Post_DL.value;

  set Dart_Post_DL(Dart_Post_Type value) => _Dart_Post_DL.value = value;

  late final ffi.Pointer<Dart_NewSendPort_Type> _Dart_NewSendPort_DL =
      _lookup<Dart_NewSendPort_Type>('Dart_NewSendPort_DL');

  Dart_NewSendPort_Type get Dart_NewSendPort_DL => _Dart_NewSendPort_DL.value;

  set Dart_NewSendPort_DL(Dart_NewSendPort_Type value) =>
      _Dart_NewSendPort_DL.value = value;

  late final ffi.Pointer<Dart_SendPortGetId_Type> _Dart_SendPortGetId_DL =
      _lookup<Dart_SendPortGetId_Type>('Dart_SendPortGetId_DL');

  Dart_SendPortGetId_Type get Dart_SendPortGetId_DL =>
      _Dart_SendPortGetId_DL.value;

  set Dart_SendPortGetId_DL(Dart_SendPortGetId_Type value) =>
      _Dart_SendPortGetId_DL.value = value;

  late final ffi.Pointer<Dart_EnterScope_Type> _Dart_EnterScope_DL =
      _lookup<Dart_EnterScope_Type>('Dart_EnterScope_DL');

  Dart_EnterScope_Type get Dart_EnterScope_DL => _Dart_EnterScope_DL.value;

  set Dart_EnterScope_DL(Dart_EnterScope_Type value) =>
      _Dart_EnterScope_DL.value = value;

  late final ffi.Pointer<Dart_ExitScope_Type> _Dart_ExitScope_DL =
      _lookup<Dart_ExitScope_Type>('Dart_ExitScope_DL');

  Dart_ExitScope_Type get Dart_ExitScope_DL => _Dart_ExitScope_DL.value;

  set Dart_ExitScope_DL(Dart_ExitScope_Type value) =>
      _Dart_ExitScope_DL.value = value;

  late final ffi.Pointer<Dart_IsNull_Type> _Dart_IsNull_DL =
      _lookup<Dart_IsNull_Type>('Dart_IsNull_DL');

  Dart_IsNull_Type get Dart_IsNull_DL => _Dart_IsNull_DL.value;

  set Dart_IsNull_DL(Dart_IsNull_Type value) => _Dart_IsNull_DL.value = value;

  late final ffi.Pointer<Dart_UpdateExternalSize_Type>
      _Dart_UpdateExternalSize_DL =
      _lookup<Dart_UpdateExternalSize_Type>('Dart_UpdateExternalSize_DL');

  Dart_UpdateExternalSize_Type get Dart_UpdateExternalSize_DL =>
      _Dart_UpdateExternalSize_DL.value;

  set Dart_UpdateExternalSize_DL(Dart_UpdateExternalSize_Type value) =>
      _Dart_UpdateExternalSize_DL.value = value;

  late final ffi.Pointer<Dart_UpdateFinalizableExternalSize_Type>
      _Dart_UpdateFinalizableExternalSize_DL =
      _lookup<Dart_UpdateFinalizableExternalSize_Type>(
          'Dart_UpdateFinalizableExternalSize_DL');

  Dart_UpdateFinalizableExternalSize_Type
      get Dart_UpdateFinalizableExternalSize_DL =>
          _Dart_UpdateFinalizableExternalSize_DL.value;

  set Dart_UpdateFinalizableExternalSize_DL(
          Dart_UpdateFinalizableExternalSize_Type value) =>
      _Dart_UpdateFinalizableExternalSize_DL.value = value;
}

typedef va_list = ffi.Pointer<ffi.Char>;

final class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

final class _Lldiv_t extends ffi.Struct {
  @intmax_t()
  external int quot;

  @intmax_t()
  external int rem;
}

typedef intmax_t = ffi.LongLong;
typedef imaxdiv_t = _Lldiv_t;
typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;
typedef uintmax_t = ffi.UnsignedLongLong;

final class _Dart_Isolate extends ffi.Opaque {}

final class _Dart_IsolateGroup extends ffi.Opaque {}

final class _Dart_Handle extends ffi.Opaque {}

final class _Dart_WeakPersistentHandle extends ffi.Opaque {}

final class _Dart_FinalizableHandle extends ffi.Opaque {}

typedef Dart_WeakPersistentHandle = ffi.Pointer<_Dart_WeakPersistentHandle>;
typedef Dart_HandleFinalizer = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> isolate_callback_data,
            ffi.Pointer<ffi.Void> peer)>>;
typedef Dart_FinalizableHandle = ffi.Pointer<_Dart_FinalizableHandle>;

final class Dart_IsolateFlags extends ffi.Struct {
  @ffi.Int32()
  external int version;

  @ffi.Bool()
  external bool enable_asserts;

  @ffi.Bool()
  external bool use_field_guards;

  @ffi.Bool()
  external bool use_osr;

  @ffi.Bool()
  external bool obfuscate;

  @ffi.Bool()
  external bool load_vmservice_library;

  @ffi.Bool()
  external bool copy_parent_code;

  @ffi.Bool()
  external bool null_safety;

  @ffi.Bool()
  external bool is_system_isolate;

  @ffi.Bool()
  external bool snapshot_is_dontneed_safe;

  @ffi.Bool()
  external bool branch_coverage;
}

/// Forward declaration
final class Dart_CodeObserver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external Dart_OnNewCodeCallback on_new_code;
}

/// Callback provided by the embedder that is used by the VM to notify on code
/// object creation, *before* it is invoked the first time.
/// This is useful for embedders wanting to e.g. keep track of PCs beyond
/// the lifetime of the garbage collected code objects.
/// Note that an address range may be used by more than one code object over the
/// lifecycle of a process. Clients of this function should record timestamps for
/// these compilation events and when collecting PCs to disambiguate reused
/// address ranges.
typedef Dart_OnNewCodeCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<Dart_CodeObserver> observer,
            ffi.Pointer<ffi.Char> name, ffi.UintPtr base, ffi.UintPtr size)>>;

/// Describes how to initialize the VM. Used with Dart_Initialize.
final class Dart_InitializeParams extends ffi.Struct {
  /// Identifies the version of the struct used by the client.
  /// should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  @ffi.Int32()
  external int version;

  /// A buffer containing snapshot data, or NULL if no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_data;

  /// A buffer containing a snapshot of precompiled instructions, or NULL if
  /// no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_instructions;

  /// A function to be called during isolate group creation.
  /// See Dart_IsolateGroupCreateCallback.
  external Dart_IsolateGroupCreateCallback create_group;

  /// A function to be called during isolate
  /// initialization inside an existing isolate group.
  /// See Dart_InitializeIsolateCallback.
  external Dart_InitializeIsolateCallback initialize_isolate;

  /// A function to be called right before an isolate is shutdown.
  /// See Dart_IsolateShutdownCallback.
  external Dart_IsolateShutdownCallback shutdown_isolate;

  /// A function to be called after an isolate was shutdown.
  /// See Dart_IsolateCleanupCallback.
  external Dart_IsolateCleanupCallback cleanup_isolate;

  /// A function to be called after an isolate group is
  /// shutdown. See Dart_IsolateGroupCleanupCallback.
  external Dart_IsolateGroupCleanupCallback cleanup_group;

  external Dart_ThreadStartCallback thread_start;

  external Dart_ThreadExitCallback thread_exit;

  external Dart_FileOpenCallback file_open;

  external Dart_FileReadCallback file_read;

  external Dart_FileWriteCallback file_write;

  external Dart_FileCloseCallback file_close;

  external Dart_EntropySource entropy_source;

  /// A function to be called by the service isolate when it requires the
  /// vmservice assets archive. See Dart_GetVMServiceAssetsArchive.
  external Dart_GetVMServiceAssetsArchive get_service_assets;

  @ffi.Bool()
  external bool start_kernel_isolate;

  /// An external code observer callback function. The observer can be invoked
  /// as early as during the Dart_Initialize() call.
  external ffi.Pointer<Dart_CodeObserver> code_observer;

  /// Kernel blob registration callback function. See Dart_RegisterKernelBlobCallback.
  external Dart_RegisterKernelBlobCallback register_kernel_blob;

  /// Kernel blob unregistration callback function. See Dart_UnregisterKernelBlobCallback.
  external Dart_UnregisterKernelBlobCallback unregister_kernel_blob;
}

/// An isolate creation and initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM
/// needs to create an isolate. The callback should create an isolate
/// by calling Dart_CreateIsolateGroup and load any scripts required for
/// execution.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns NULL, it is the responsibility of this
/// function to ensure that Dart_ShutdownIsolate has been called if
/// required (for example, if the isolate was created successfully by
/// Dart_CreateIsolateGroup() but the root library fails to load
/// successfully, then the function should call Dart_ShutdownIsolate
/// before returning).
///
/// When the function returns NULL, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param script_uri The uri of the main source file or snapshot to load.
/// Either the URI of the parent isolate set in Dart_CreateIsolateGroup for
/// Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the
/// library tag handler of the parent isolate.
/// The callback is responsible for loading the program by a call to
/// Dart_LoadScriptFromKernel.
/// \param main The name of the main entry point this isolate will
/// eventually run.  This is provided for advisory purposes only to
/// improve debugging messages.  The main function is not invoked by
/// this function.
/// \param package_root Ignored.
/// \param package_config Uri of the package configuration file (either in format
/// of .packages or .dart_tool/package_config.json) for this isolate
/// to resolve package imports against. If this parameter is not passed the
/// package resolution of the parent isolate should be used.
/// \param flags Default flags for this isolate being spawned. Either inherited
/// from the spawning isolate or passed as parameters when spawning the
/// isolate from Dart code.
/// \param isolate_data The isolate data which was passed to the
/// parent isolate when it was created by calling Dart_CreateIsolateGroup().
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case of failures.
///
/// \return The embedder returns NULL if the creation and
/// initialization was not successful and the isolate if successful.
typedef Dart_IsolateGroupCreateCallback = ffi.Pointer<
    ffi.NativeFunction<
        Dart_Isolate Function(
            ffi.Pointer<ffi.Char> script_uri,
            ffi.Pointer<ffi.Char> main,
            ffi.Pointer<ffi.Char> package_root,
            ffi.Pointer<ffi.Char> package_config,
            ffi.Pointer<Dart_IsolateFlags> flags,
            ffi.Pointer<ffi.Void> isolate_data,
            ffi.Pointer<ffi.Pointer<ffi.Char>> error)>>;

/// An isolate is the unit of concurrency in Dart. Each isolate has
/// its own memory and thread of control. No state is shared between
/// isolates. Instead, isolates communicate by message passing.
///
/// Each thread keeps track of its current isolate, which is the
/// isolate which is ready to execute on the current thread. The
/// current isolate may be NULL, in which case no isolate is ready to
/// execute. Most of the Dart apis require there to be a current
/// isolate in order to function without error. The current isolate is
/// set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate.
typedef Dart_Isolate = ffi.Pointer<_Dart_Isolate>;

/// An isolate initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM has created an
/// isolate within an existing isolate group (i.e. from the same source as an
/// existing isolate).
///
/// The callback should setup native resolvers and might want to set a custom
/// message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as
/// runnable.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns `false`, it is the responsibility of this
/// function to ensure that `Dart_ShutdownIsolate` has been called.
///
/// When the function returns `false`, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param child_isolate_data The callback data to associate with the new
/// child isolate.
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case the initialization fails.
///
/// \return The embedder returns true if the initialization was successful and
/// false otherwise (in which case the VM will terminate the isolate).
typedef Dart_InitializeIsolateCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<ffi.Pointer<ffi.Void>> child_isolate_data,
            ffi.Pointer<ffi.Pointer<ffi.Char>> error)>>;

/// An isolate shutdown callback function.
///
/// This callback, provided by the embedder, is called before the vm
/// shuts down an isolate.  The isolate being shutdown will be the current
/// isolate. It is safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateShutdownCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> isolate_group_data,
            ffi.Pointer<ffi.Void> isolate_data)>>;

/// An isolate cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate. There will be no current isolate and it is *not*
/// safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateCleanupCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> isolate_group_data,
            ffi.Pointer<ffi.Void> isolate_data)>>;

/// An isolate group cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate group.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
typedef Dart_IsolateGroupCleanupCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> isolate_group_data)>>;

/// A thread start callback function.
/// This callback, provided by the embedder, is called after a thread in the
/// vm thread pool starts.
/// This function could be used to adjust thread priority or attach native
/// resources to the thread.
typedef Dart_ThreadStartCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// A thread death callback function.
/// This callback, provided by the embedder, is called before a thread in the
/// vm thread pool exits.
/// This function could be used to dispose of native resources that
/// are associated and attached to the thread, in order to avoid leaks.
typedef Dart_ThreadExitCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// Opens a file for reading or writing.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param name The name of the file to open.
/// \param write A boolean variable which indicates if the file is to
/// opened for writing. If there is an existing file it needs to truncated.
typedef Dart_FileOpenCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Char> name, ffi.Bool write)>>;

/// Read contents of file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer allocated in the callback into which the contents
/// of the file are read into. It is the responsibility of the caller to
/// free this buffer.
/// \param file_length A variable into which the length of the file is returned.
/// In the case of an error this value would be -1.
/// \param stream Handle to the opened file.
typedef Dart_FileReadCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
            ffi.Pointer<ffi.IntPtr> file_length,
            ffi.Pointer<ffi.Void> stream)>>;

/// Write data into file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer which needs to be written into the file.
/// \param length Length of the buffer.
/// \param stream Handle to the opened file.
typedef Dart_FileWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> data, ffi.IntPtr length,
            ffi.Pointer<ffi.Void> stream)>>;

/// Closes the opened file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param stream Handle to the opened file.
typedef Dart_FileCloseCallback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> stream)>>;
typedef Dart_EntropySource = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<ffi.Uint8> buffer, ffi.IntPtr length)>>;

/// Callback provided by the embedder that is used by the vmservice isolate
/// to request the asset archive. The asset archive must be an uncompressed tar
/// archive that is stored in a Uint8List.
///
/// If the embedder has no vmservice isolate assets, the callback can be NULL.
///
/// \return The embedder must return a handle to a Uint8List containing an
/// uncompressed tar archive or null.
typedef Dart_GetVMServiceAssetsArchive
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>;

/// Optional callback provided by the embedder that is used by the VM to
/// implement registration of kernel blobs for the subsequent Isolate.spawnUri
/// If no callback is provided, the registration of kernel blobs will throw
/// an error.
///
/// \param kernel_buffer A buffer which contains a kernel program. Callback
/// should copy the contents of `kernel_buffer` as
/// it may be freed immediately after registration.
/// \param kernel_buffer_size The size of `kernel_buffer`.
///
/// \return A C string representing URI which can be later used
/// to spawn a new isolate. This C String should be scope allocated
/// or owned by the embedder.
/// Returns NULL if embedder runs out of memory.
typedef Dart_RegisterKernelBlobCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Uint8> kernel_buffer,
            ffi.IntPtr kernel_buffer_size)>>;

/// Optional callback provided by the embedder that is used by the VM to
/// unregister kernel blobs.
/// If no callback is provided, the unregistration of kernel blobs will throw
/// an error.
///
/// \param kernel_blob_uri URI of the kernel blob to unregister.
typedef Dart_UnregisterKernelBlobCallback = ffi.Pointer<
    ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char> kernel_blob_uri)>>;
typedef Dart_IsolateGroup = ffi.Pointer<_Dart_IsolateGroup>;

/// Gets an id that uniquely identifies current isolate group.
///
/// It is the responsibility of the caller to free the returned ID.
typedef Dart_IsolateGroupId = ffi.Int64;
typedef Dart_HeapSamplingCreateCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            Dart_Isolate isolate,
            Dart_IsolateGroup isolate_group,
            ffi.Pointer<ffi.Char> cls_name,
            ffi.IntPtr allocation_size)>>;
typedef Dart_HeapSamplingDeleteCallback = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>;
typedef Dart_HeapSamplingReportCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.Void> data)>>;

abstract class Dart_PerformanceMode {
  /// Balanced
  static const int Dart_PerformanceMode_Default = 0;

  /// Optimize for low latency, at the expense of throughput and memory overhead
  /// by performing work in smaller batches (requiring more overhead) or by
  /// delaying work (requiring more memory). An embedder should not remain in
  /// this mode indefinitely.
  static const int Dart_PerformanceMode_Latency = 1;

  /// Optimize for high throughput, at the expense of latency and memory overhead
  /// by performing work in larger batches with more intervening growth.
  static const int Dart_PerformanceMode_Throughput = 2;

  /// Optimize for low memory, at the expensive of throughput and latency by more
  /// frequently performing work.
  static const int Dart_PerformanceMode_Memory = 3;
}

/// A message notification callback.
///
/// This callback allows the embedder to provide a custom wakeup mechanism for
/// the delivery of inter-isolate messages. This function is called once per
/// message on an arbitrary thread. It is the responsibility of the embedder to
/// eventually call Dart_HandleMessage once per callback received with the
/// destination isolate set as the current isolate to process the message.
typedef Dart_MessageNotifyCallback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(Dart_Isolate destination_isolate)>>;

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;

abstract class Dart_CoreType_Id {
  static const int Dart_CoreType_Dynamic = 0;
  static const int Dart_CoreType_Int = 1;
  static const int Dart_CoreType_String = 2;
}

abstract class Dart_TypedData_Type {
  static const int Dart_TypedData_kByteData = 0;
  static const int Dart_TypedData_kInt8 = 1;
  static const int Dart_TypedData_kUint8 = 2;
  static const int Dart_TypedData_kUint8Clamped = 3;
  static const int Dart_TypedData_kInt16 = 4;
  static const int Dart_TypedData_kUint16 = 5;
  static const int Dart_TypedData_kInt32 = 6;
  static const int Dart_TypedData_kUint32 = 7;
  static const int Dart_TypedData_kInt64 = 8;
  static const int Dart_TypedData_kUint64 = 9;
  static const int Dart_TypedData_kFloat32 = 10;
  static const int Dart_TypedData_kFloat64 = 11;
  static const int Dart_TypedData_kInt32x4 = 12;
  static const int Dart_TypedData_kFloat32x4 = 13;
  static const int Dart_TypedData_kFloat64x2 = 14;
  static const int Dart_TypedData_kInvalid = 15;
}

final class _Dart_NativeArguments extends ffi.Opaque {}

/// The arguments to a native function.
///
/// This object is passed to a native function to represent its
/// arguments and return value. It allows access to the arguments to a
/// native function by index. It also allows the return value of a
/// native function to be set.
typedef Dart_NativeArguments = ffi.Pointer<_Dart_NativeArguments>;

abstract class Dart_NativeArgument_Type {
  static const int Dart_NativeArgument_kBool = 0;
  static const int Dart_NativeArgument_kInt32 = 1;
  static const int Dart_NativeArgument_kUint32 = 2;
  static const int Dart_NativeArgument_kInt64 = 3;
  static const int Dart_NativeArgument_kUint64 = 4;
  static const int Dart_NativeArgument_kDouble = 5;
  static const int Dart_NativeArgument_kString = 6;
  static const int Dart_NativeArgument_kInstance = 7;
  static const int Dart_NativeArgument_kNativeFields = 8;
}

final class _Dart_NativeArgument_Descriptor extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int index;
}

final class _Dart_NativeArgument_Value extends ffi.Opaque {}

typedef Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;
typedef Dart_NativeArgument_Value = _Dart_NativeArgument_Value;

/// An environment lookup callback function.
///
/// \param name The name of the value to lookup in the environment.
///
/// \return A valid handle to a string if the name exists in the
/// current environment or Dart_Null() if not.
typedef Dart_EnvironmentCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle name)>>;

/// Native entry resolution callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a native entry resolver. This callback is used to map a
/// name/arity to a Dart_NativeFunction. If no function is found, the
/// callback should return NULL.
///
/// The parameters to the native resolver function are:
/// \param name a Dart string which is the name of the native function.
/// \param num_of_arguments is the number of arguments expected by the
/// native function.
/// \param auto_setup_scope is a boolean flag that can be set by the resolver
/// to indicate if this function needs a Dart API scope (see Dart_EnterScope/
/// Dart_ExitScope) to be setup automatically by the VM before calling into
/// the native function. By default most native functions would require this
/// to be true but some light weight native functions which do not call back
/// into the VM through the Dart API may not require a Dart scope to be
/// setup automatically.
///
/// \return A valid Dart_NativeFunction which resolves to a native entry point
/// for the native function.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntryResolver = ffi.Pointer<
    ffi.NativeFunction<
        Dart_NativeFunction Function(ffi.Handle name, ffi.Int num_of_arguments,
            ffi.Pointer<ffi.Bool> auto_setup_scope)>>;

/// A native function.
typedef Dart_NativeFunction = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(Dart_NativeArguments arguments)>>;

/// Native entry symbol lookup callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a callback for mapping a native entry to a symbol. This callback
/// maps a native function entry PC to the native function name. If no native
/// entry symbol can be found, the callback should return NULL.
///
/// The parameters to the native reverse resolver function are:
/// \param nf A Dart_NativeFunction.
///
/// \return A const UTF-8 string containing the symbol name or NULL.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntrySymbol = ffi.Pointer<
    ffi
    .NativeFunction<ffi.Pointer<ffi.Uint8> Function(Dart_NativeFunction nf)>>;

/// FFI Native C function pointer resolver callback.
///
/// See Dart_SetFfiNativeResolver.
typedef Dart_FfiNativeResolver = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<ffi.Char> name, ffi.UintPtr args_n)>>;

abstract class Dart_LibraryTag {
  static const int Dart_kCanonicalizeUrl = 0;
  static const int Dart_kImportTag = 1;
  static const int Dart_kKernelTag = 2;
}

/// The library tag handler is a multi-purpose callback provided by the
/// embedder to the Dart VM. The embedder implements the tag handler to
/// provide the ability to load Dart scripts and imports.
///
/// -- TAGS --
///
/// Dart_kCanonicalizeUrl
///
/// This tag indicates that the embedder should canonicalize 'url' with
/// respect to 'library'.  For most embedders, the
/// Dart_DefaultCanonicalizeUrl function is a sufficient implementation
/// of this tag.  The return value should be a string holding the
/// canonicalized url.
///
/// Dart_kImportTag
///
/// This tag is used to load a library from IsolateMirror.loadUri. The embedder
/// should call Dart_LoadLibraryFromKernel to provide the library to the VM. The
/// return value should be an error or library (the result from
/// Dart_LoadLibraryFromKernel).
///
/// Dart_kKernelTag
///
/// This tag is used to load the intermediate file (kernel) generated by
/// the Dart front end. This tag is typically used when a 'hot-reload'
/// of an application is needed and the VM is 'use dart front end' mode.
/// The dart front end typically compiles all the scripts, imports and part
/// files into one intermediate file hence we don't use the source/import or
/// script tags. The return value should be an error or a TypedData containing
/// the kernel bytes.
typedef Dart_LibraryTagHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Handle Function(ffi.Int32 tag,
            ffi.Handle library_or_package_map_url, ffi.Handle url)>>;

/// Handles deferred loading requests. When this handler is invoked, it should
/// eventually load the deferred loading unit with the given id and call
/// Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is
/// recommended that the loading occur asynchronously, but it is permitted to
/// call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the
/// handler returns.
///
/// If an error is returned, it will be propagated through
/// `prefix.loadLibrary()`. This is useful for synchronous
/// implementations, which must propagate any unwind errors from
/// Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler
/// should return a non-error such as `Dart_Null()`.
typedef Dart_DeferredLoadHandler = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr loading_unit_id)>>;

/// Experimental support for Dart to Kernel parser isolate.
///
/// TODO(hausner): Document finalized interface.
abstract class Dart_KernelCompilationStatus {
  static const int Dart_KernelCompilationStatus_Unknown = -1;
  static const int Dart_KernelCompilationStatus_Ok = 0;
  static const int Dart_KernelCompilationStatus_Error = 1;
  static const int Dart_KernelCompilationStatus_Crash = 2;
  static const int Dart_KernelCompilationStatus_MsgFailed = 3;
}

final class Dart_KernelCompilationResult extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<ffi.Char> error;

  external ffi.Pointer<ffi.Uint8> kernel;

  @ffi.IntPtr()
  external int kernel_size;
}

abstract class Dart_KernelCompilationVerbosityLevel {
  static const int Dart_KernelCompilationVerbosityLevel_Error = 0;
  static const int Dart_KernelCompilationVerbosityLevel_Warning = 1;
  static const int Dart_KernelCompilationVerbosityLevel_Info = 2;
  static const int Dart_KernelCompilationVerbosityLevel_All = 3;
}

final class Dart_SourceFile extends ffi.Struct {
  external ffi.Pointer<ffi.Char> uri;

  external ffi.Pointer<ffi.Char> source;
}

typedef Dart_StreamingWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> callback_data,
            ffi.Pointer<ffi.Uint8> buffer, ffi.IntPtr size)>>;
typedef Dart_CreateLoadingUnitCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void> callback_data,
            ffi.IntPtr loading_unit_id,
            ffi.Pointer<ffi.Pointer<ffi.Void>> write_callback_data,
            ffi.Pointer<ffi.Pointer<ffi.Void>> write_debug_callback_data)>>;
typedef Dart_StreamingCloseCallback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> callback_data)>>;

/// Callback provided by the embedder that is used by the VM to
/// produce footnotes appended to DWARF stack traces.
///
/// Whenever VM formats a stack trace as a string it would call this callback
/// passing raw program counters for each frame in the stack trace.
///
/// Embedder can then return a string which if not-null will be appended to the
/// formatted stack trace.
///
/// Returned string is expected to be `malloc()` allocated. VM takes ownership
/// of the returned string and will `free()` it.
///
/// \param addresses raw program counter addresses for each frame
/// \param count number of elements in the addresses array
typedef Dart_DwarfStackTraceFootnoteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<ffi.Pointer<ffi.Void>> addresses, ffi.IntPtr count)>>;

/// A Dart_CObject is used for representing Dart objects as native C
/// data outside the Dart heap. These objects are totally detached from
/// the Dart heap. Only a subset of the Dart objects have a
/// representation as a Dart_CObject.
///
/// The string encoding in the 'value.as_string' is UTF-8.
///
/// All the different types from dart:typed_data are exposed as type
/// kTypedData. The specific type from dart:typed_data is in the type
/// field of the as_typed_data structure. The length in the
/// as_typed_data structure is always in bytes.
///
/// The data for kTypedData is copied on message send and ownership remains with
/// the caller. The ownership of data for kExternalTyped is passed to the VM on
/// message send and returned when the VM invokes the
/// Dart_HandleFinalizer callback; a non-NULL callback must be provided.
///
/// Note that Dart_CObject_kNativePointer is intended for internal use by
/// dart:io implementation and has no connection to dart:ffi Pointer class.
/// It represents a pointer to a native resource of a known type.
/// The receiving side will only see this pointer as an integer and will not
/// see the specified finalizer.
/// The specified finalizer will only be invoked if the message is not delivered.
abstract class Dart_CObject_Type {
  static const int Dart_CObject_kNull = 0;
  static const int Dart_CObject_kBool = 1;
  static const int Dart_CObject_kInt32 = 2;
  static const int Dart_CObject_kInt64 = 3;
  static const int Dart_CObject_kDouble = 4;
  static const int Dart_CObject_kString = 5;
  static const int Dart_CObject_kArray = 6;
  static const int Dart_CObject_kTypedData = 7;
  static const int Dart_CObject_kExternalTypedData = 8;
  static const int Dart_CObject_kSendPort = 9;
  static const int Dart_CObject_kCapability = 10;
  static const int Dart_CObject_kNativePointer = 11;
  static const int Dart_CObject_kUnsupported = 12;
  static const int Dart_CObject_kUnmodifiableExternalTypedData = 13;
  static const int Dart_CObject_kNumberOfTypes = 14;
}

final class _Dart_CObject extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external UnnamedUnion1 value;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Bool()
  external bool as_bool;

  @ffi.Int32()
  external int as_int32;

  @ffi.Int64()
  external int as_int64;

  @ffi.Double()
  external double as_double;

  external ffi.Pointer<ffi.Char> as_string;

  external UnnamedStruct3 as_send_port;

  external UnnamedStruct4 as_capability;

  external UnnamedStruct5 as_array;

  external UnnamedStruct6 as_typed_data;

  external UnnamedStruct7 as_external_typed_data;

  external UnnamedStruct8 as_native_pointer;
}

final class UnnamedStruct3 extends ffi.Struct {
  @Dart_Port()
  external int id;

  @Dart_Port()
  external int origin_id;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.Int64()
  external int id;
}

final class UnnamedStruct5 extends ffi.Struct {
  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Pointer<_Dart_CObject>> values;
}

final class UnnamedStruct6 extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Uint8> values;
}

final class UnnamedStruct7 extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Uint8> data;

  external ffi.Pointer<ffi.Void> peer;

  external Dart_HandleFinalizer callback;
}

final class UnnamedStruct8 extends ffi.Struct {
  @ffi.IntPtr()
  external int ptr;

  @ffi.IntPtr()
  external int size;

  external Dart_HandleFinalizer callback;
}

typedef Dart_CObject = _Dart_CObject;

/// A native message handler.
///
/// This handler is associated with a native port by calling
/// Dart_NewNativePort.
///
/// The message received is decoded into the message structure. The
/// lifetime of the message data is controlled by the caller. All the
/// data references from the message are allocated by the caller and
/// will be reclaimed when returning to it.
typedef Dart_NativeMessageHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            Dart_Port dest_port_id, ffi.Pointer<Dart_CObject> message)>>;
typedef Dart_PostCObject_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(
            Dart_Port_DL port_id, ffi.Pointer<Dart_CObject> message)>>;
typedef Dart_Port_DL = ffi.Int64;
typedef Dart_PostInteger_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(Dart_Port_DL port_id, ffi.Int64 message)>>;
typedef Dart_NewNativePort_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_Port_DL Function(
            ffi.Pointer<ffi.Char> name,
            Dart_NativeMessageHandler_DL handler,
            ffi.Bool handle_concurrently)>>;
typedef Dart_NativeMessageHandler_DL = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            Dart_Port_DL dest_port_id, ffi.Pointer<Dart_CObject> message)>>;
typedef Dart_CloseNativePort_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(Dart_Port_DL native_port_id)>>;
typedef Dart_IsError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_IsApiError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_IsUnhandledExceptionError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_IsCompilationError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_IsFatalError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_GetError_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle handle)>>;
typedef Dart_ErrorHasException_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle handle)>>;
typedef Dart_ErrorGetException_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle handle)>>;
typedef Dart_ErrorGetStackTrace_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle handle)>>;
typedef Dart_NewApiError_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char> error)>>;
typedef Dart_NewCompilationError_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char> error)>>;
typedef Dart_NewUnhandledExceptionError_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle exception)>>;
typedef Dart_PropagateError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle handle)>>;
typedef Dart_HandleFromPersistent_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle object)>>;
typedef Dart_HandleFromWeakPersistent_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle object)>>;
typedef Dart_NewPersistentHandle_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle object)>>;
typedef Dart_SetPersistentHandle_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Handle obj1, ffi.Handle obj2)>>;
typedef Dart_DeletePersistentHandle_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle object)>>;
typedef Dart_NewWeakPersistentHandle_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_WeakPersistentHandle Function(
            ffi.Handle object,
            ffi.Pointer<ffi.Void> peer,
            ffi.IntPtr external_allocation_size,
            Dart_HandleFinalizer callback)>>;
typedef Dart_DeleteWeakPersistentHandle_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle object)>>;
typedef Dart_NewFinalizableHandle_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_FinalizableHandle Function(
            ffi.Handle object,
            ffi.Pointer<ffi.Void> peer,
            ffi.IntPtr external_allocation_size,
            Dart_HandleFinalizer callback)>>;
typedef Dart_DeleteFinalizableHandle_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            Dart_FinalizableHandle object, ffi.Handle strong_ref_to_object)>>;
typedef Dart_CurrentIsolate_Type
    = ffi.Pointer<ffi.NativeFunction<Dart_Isolate Function()>>;
typedef Dart_ExitIsolate_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;
typedef Dart_EnterIsolate_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>;
typedef Dart_Post_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(Dart_Port_DL port_id, ffi.Handle object)>>;
typedef Dart_NewSendPort_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_Port_DL port_id)>>;
typedef Dart_SendPortGetId_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Handle Function(
            ffi.Handle port, ffi.Pointer<Dart_Port_DL> port_id)>>;
typedef Dart_EnterScope_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;
typedef Dart_ExitScope_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;
typedef Dart_IsNull_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_UpdateExternalSize_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(Dart_WeakPersistentHandle object,
            ffi.IntPtr external_allocation_size)>>;
typedef Dart_UpdateFinalizableExternalSize_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            Dart_FinalizableHandle object,
            ffi.Handle strong_ref_to_object,
            ffi.IntPtr external_allocation_size)>>;

const int kNativeArgNumberPos = 0;

const int kNativeArgNumberSize = 8;

const int kNativeArgTypePos = 8;

const int kNativeArgTypeSize = 8;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int _WCHAR_T_DEFINED = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 'C';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const String PRId8 = 'hhd';

const String PRId16 = 'hd';

const String PRId32 = 'd';

const String PRId64 = 'lld';

const String PRIdLEAST8 = 'hhd';

const String PRIdLEAST16 = 'hd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'lld';

const String PRIdFAST8 = 'hhd';

const String PRIdFAST16 = 'd';

const String PRIdFAST32 = 'd';

const String PRIdFAST64 = 'lld';

const String PRIdMAX = 'lld';

const String PRIdPTR = 'lld';

const String PRIi8 = 'hhi';

const String PRIi16 = 'hi';

const String PRIi32 = 'i';

const String PRIi64 = 'lli';

const String PRIiLEAST8 = 'hhi';

const String PRIiLEAST16 = 'hi';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'lli';

const String PRIiFAST8 = 'hhi';

const String PRIiFAST16 = 'i';

const String PRIiFAST32 = 'i';

const String PRIiFAST64 = 'lli';

const String PRIiMAX = 'lli';

const String PRIiPTR = 'lli';

const String PRIo8 = 'hho';

const String PRIo16 = 'ho';

const String PRIo32 = 'o';

const String PRIo64 = 'llo';

const String PRIoLEAST8 = 'hho';

const String PRIoLEAST16 = 'ho';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'llo';

const String PRIoFAST8 = 'hho';

const String PRIoFAST16 = 'o';

const String PRIoFAST32 = 'o';

const String PRIoFAST64 = 'llo';

const String PRIoMAX = 'llo';

const String PRIoPTR = 'llo';

const String PRIu8 = 'hhu';

const String PRIu16 = 'hu';

const String PRIu32 = 'u';

const String PRIu64 = 'llu';

const String PRIuLEAST8 = 'hhu';

const String PRIuLEAST16 = 'hu';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'llu';

const String PRIuFAST8 = 'hhu';

const String PRIuFAST16 = 'u';

const String PRIuFAST32 = 'u';

const String PRIuFAST64 = 'llu';

const String PRIuMAX = 'llu';

const String PRIuPTR = 'llu';

const String PRIx8 = 'hhx';

const String PRIx16 = 'hx';

const String PRIx32 = 'x';

const String PRIx64 = 'llx';

const String PRIxLEAST8 = 'hhx';

const String PRIxLEAST16 = 'hx';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'llx';

const String PRIxFAST8 = 'hhx';

const String PRIxFAST16 = 'x';

const String PRIxFAST32 = 'x';

const String PRIxFAST64 = 'llx';

const String PRIxMAX = 'llx';

const String PRIxPTR = 'llx';

const String PRIX8 = 'hhX';

const String PRIX16 = 'hX';

const String PRIX32 = 'X';

const String PRIX64 = 'llX';

const String PRIXLEAST8 = 'hhX';

const String PRIXLEAST16 = 'hX';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'llX';

const String PRIXFAST8 = 'hhX';

const String PRIXFAST16 = 'X';

const String PRIXFAST32 = 'X';

const String PRIXFAST64 = 'llX';

const String PRIXMAX = 'llX';

const String PRIXPTR = 'llX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'lld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'lld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'd';

const String SCNdFAST32 = 'd';

const String SCNdFAST64 = 'lld';

const String SCNdMAX = 'lld';

const String SCNdPTR = 'lld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'lli';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'lli';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'i';

const String SCNiFAST32 = 'i';

const String SCNiFAST64 = 'lli';

const String SCNiMAX = 'lli';

const String SCNiPTR = 'lli';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'llo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'llo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'o';

const String SCNoFAST32 = 'o';

const String SCNoFAST64 = 'llo';

const String SCNoMAX = 'llo';

const String SCNoPTR = 'llo';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'llu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'llu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'u';

const String SCNuFAST32 = 'u';

const String SCNuFAST64 = 'llu';

const String SCNuMAX = 'llu';

const String SCNuPTR = 'llu';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'llx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'llx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'x';

const String SCNxFAST32 = 'x';

const String SCNxFAST64 = 'llx';

const String SCNxMAX = 'llx';

const String SCNxPTR = 'llx';

const int __bool_true_false_are_defined = 1;

const int false1 = 0;

const int true1 = 1;

const int DART_FLAGS_CURRENT_VERSION = 12;

const int DART_INITIALIZE_PARAMS_CURRENT_VERSION = 8;

const int ILLEGAL_PORT = 0;

const String DART_KERNEL_ISOLATE_NAME = 'kernel-service';

const String DART_VM_SERVICE_ISOLATE_NAME = 'vm-service';

const String kSnapshotBuildIdCSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataCSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsCSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssCSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataCSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsCSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssCSymbol = '_kDartIsolateSnapshotBss';

const String kSnapshotBuildIdAsmSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataAsmSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsAsmSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssAsmSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataAsmSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsAsmSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssAsmSymbol = '_kDartIsolateSnapshotBss';
